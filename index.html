<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>TRT・PRA ABMシミュレータ v6.0（研究用・単一HTML）</title>
  <!-- three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <style>
    :root {
      --panel-bg: #ffffff;
      --panel-shadow: 0 4px 20px rgba(0,0,0,0.12);
      --panel-radius: 12px;
      --panel-border: 1px solid #e5e7eb;
      --text-1: #1f2937;
      --text-2: #374151;
      --text-3: #4b5563;
      --muted:  #6b7280;
      --brand:  #3b82f6;
      --brand-2:#2563eb;
      --bg-1:   #f0f2f5;
      --bg-2:   #f8fafb;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg-1);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, system-ui, Arial, sans-serif;
      color: var(--text-1);
    }

    /* 2ペイン・レイアウト（重なり根絶） */
    #layout {
      display: grid;
      grid-template-columns: 1fr 380px;
      grid-template-rows: 100vh;
      gap: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #stage {
      position: relative;
      min-width: 0;
      min-height: 0;
      background: #f8f8f8;
    }

    #sidebar {
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 10px;
      background: var(--bg-2);
      border-left: 1px solid #e5e7eb;
      padding: 10px;
      overflow: hidden;
    }

    .panel {
      background: var(--panel-bg);
      border-radius: var(--panel-radius);
      box-shadow: var(--panel-shadow);
      border: var(--panel-border);
      padding: 14px;
      overflow: hidden;
      min-height: 0;
    }

    .panel h1 { font-size: 18px; margin: 0 0 8px; color: var(--text-1); }
    .panel h2 { font-size: 14px; margin: 10px 0 8px; color: var(--text-2); border-bottom: 1px solid #e5e7eb; padding-bottom: 6px; }

    .group { background: #ffffff; border: 1px solid #eef0f4; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
    .row   { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 8px 0; font-size: 12px; color: var(--text-3); }
    .row input[type="range"] { width: 100%; }
    .val   { font-size: 11px; color: var(--muted); min-width: 48px; text-align: right; }
    .row input[type="number"] { width: 90px; padding: 4px 6px; }

    .btns { display: flex; flex-wrap: wrap; gap: 6px; margin: 6px 0 0; }
    button {
      background: var(--brand);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
    }
    button.secondary { background: #e5e7eb; color: #111827; }
    button.warn { background: #ef4444; }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 12px;
      color: var(--text-3);
    }
    .stat { background: #fafbfc; border: 1px solid #eef0f4; border-radius: 8px; padding: 8px; display: grid; gap: 4px; }
    .stat .k { font-size: 11px; color: var(--muted); }
    .stat .v { font-size: 14px; color: var(--text-1); }

    /* JSONエディタ領域（比較・シナリオ編集） */
    #editor {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
    }
    #scenarioArea {
      width: 100%;
      height: 100%;
      resize: none;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      box-sizing: border-box;
      background: #ffffff;
      color: #111827;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--text-3);
    }
    .lg { display: inline-flex; align-items: center; gap: 6px; padding: 2px 6px; border-radius: 12px; background: #f3f4f6; border: 1px solid #e5e7eb; }
    .dot { width: 12px; height: 12px; border-radius: 50%; }

    /* ツールチップ */
    .tip { position: relative; display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; background: #111827; color: #fff; border-radius: 50%; font-size: 11px; cursor: help; margin-left: 6px; }
    .tip .bubble {
      position: absolute;
      left: 50%; bottom: 130%;
      transform: translateX(-50%);
      min-width: 260px; max-width: 320px;
      visibility: hidden; opacity: 0; transition: 0.2s ease;
      background: #111827; color: #fff; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.2);
      padding: 10px; z-index: 1000; font-size: 12px; line-height: 1.5;
    }
    .tip:hover .bubble { visibility: visible; opacity: 1; }

    /* レスポンシブ：縦並びで重なりを完全回避 */
    @media (max-width: 1100px) {
      #layout {
        grid-template-columns: 1fr;
        grid-template-rows: 55vh auto;
        height: auto;
      }
      #stage { height: 55vh; }
      #sidebar { height: auto; max-height: none; }
    }
    @media (max-width: 600px) {
      #layout { grid-template-rows: 50vh auto; }
      #stage  { height: 50vh; }
    }
  </style>
</head>
<body>
  <div id="layout">
    <div id="stage">
      <!-- three.js canvas will be injected here -->
    </div>
    <div id="sidebar">
      <!-- コントロール -->
      <div class="panel" id="controls">
        <h1>TRT・PRA ABM シミュレータ</h1>

        <div class="group">
          <h2>シミュレーション制御</h2>
          <div class="btns">
            <button id="btnStart">開始</button>
            <button id="btnPause" class="secondary">一時停止/再開</button>
            <button id="btnReset" class="secondary">リセット</button>
            <button id="btnExport" class="secondary">ログCSV保存</button>
            <button id="btnHeadless" class="secondary">描画OFF/ON</button>
          </div>
          <div class="row">
            <label>初期粒子数</label>
            <input id="initialParticles" type="number" min="0" max="1000" step="10" value="50" />
          </div>
          <div class="row">
            <label>最大粒子数</label>
            <input id="maxParticles" type="number" min="100" max="5000" step="50" value="1000" />
          </div>
        </div>

        <div class="group">
          <h2>時間・発生</h2>
          <div class="row">
            <label>時間スケール</label>
            <span class="val" id="v_timeScale">0.10</span>
            <input id="timeScale" type="range" min="0.01" max="1.0" step="0.01" value="0.10" />
          </div>
          <div class="row">
            <label>発生間隔[s]</label>
            <span class="val" id="v_spawnInterval">0.50</span>
            <input id="spawnInterval" type="range" min="0.05" max="2.0" step="0.05" value="0.50" />
          </div>
          <div class="row">
            <label>バッチサイズ</label>
            <span class="val" id="v_batchSize">5</span>
            <input id="batchSize" type="range" min="1" max="50" step="1" value="5" />
          </div>
        </div>

        <div class="group">
          <h2>資源タイプと初期配置
            <span class="tip">?
              <span class="bubble">
                エージェント（資源）は3タイプ：標準・活用特化（Exploiter）・探索特化（Explorer）で生成されます。<br/>
                「戦略的初期配置」を有効にすると、活用特化は中心や既存クラスター近傍、探索特化は周縁部にスポーンしやすくなります。
              </span>
            </span>
          </h2>
          <div class="row">
            <label>活用特化の発生割合</label>
            <span class="val" id="v_exploiterRatio">0.30</span>
            <input id="exploiterRatio" type="range" min="0" max="1" step="0.05" value="0.30" />
          </div>
          <div class="row">
            <label>探索特化の発生割合</label>
            <span class="val" id="v_explorerRatio">0.30</span>
            <input id="explorerRatio" type="range" min="0" max="1" step="0.05" value="0.30" />
          </div>
          <div class="row">
            <label>戦略的初期配置</label>
            <input id="strategicSpawn" type="checkbox" checked />
          </div>
        </div>

        <div class="group">
          <h2>TRT（縦推進）・PRA（横探索）
            <span class="tip">?
              <span class="bubble">
                TRTは円錐の高さ方向（成熟方向）への決定論的推進で、低高度ほど強く高高度で弱まります。<br/>
                PRAは水平方向の確率的探索で、高度に応じて強さをスケーリングします（多様性・再結合のモデル化）。
              </span>
            </span>
          </h2>
          <div class="row">
            <label>TRT強度</label>
            <span class="val" id="v_trtForce">0.015</span>
            <input id="trtForce" type="range" min="0" max="0.05" step="0.001" value="0.015" />
          </div>
          <div class="row">
            <label>PRA強度</label>
            <span class="val" id="v_praForce">0.020</span>
            <input id="praForce" type="range" min="0" max="0.05" step="0.001" value="0.020" />
          </div>
          <div class="row">
            <label>PRA多様性スケール</label>
            <span class="val" id="v_praDiversity">1.00</span>
            <input id="praDiversity" type="range" min="0.5" max="2.0" step="0.05" value="1.00" />
          </div>
        </div>

        <div class="group">
          <h2>相互作用・環境
            <span class="tip">?
              <span class="bubble">
                中央収束は組織の求心力、粒子引力は資源間の自発的協調（クラスター形成）を表します。<br/>
                成功閾値に到達した資源は成功としてカウントされ、減耗率により自然消滅も発生します。
              </span>
            </span>
          </h2>
          <div class="row">
            <label>中央収束</label>
            <span class="val" id="v_centralConv">0.030</span>
            <input id="centralConv" type="range" min="0" max="0.1" step="0.001" value="0.030" />
          </div>
          <div class="row">
            <label>粒子引力</label>
            <span class="val" id="v_peerAttr">0.010</span>
            <input id="peerAttr" type="range" min="0" max="0.05" step="0.001" value="0.010" />
          </div>
          <div class="row">
            <label>成功閾値（高度）</label>
            <span class="val" id="v_successTh">38</span>
            <input id="successTh" type="range" min="10" max="60" step="1" value="38" />
          </div>
          <div class="row">
            <label>減耗率</label>
            <span class="val" id="v_attrition">0.020</span>
            <input id="attrition" type="range" min="0" max="0.1" step="0.001" value="0.020" />
          </div>
        </div>

        <div class="group">
          <h2>組織モデルの説明
            <span class="tip">?
              <span class="bubble">
                中央集権型：上層で意思決定が集中し、効率と統一性に優れるが創発が抑制されやすい。<br/>
                分散自律型：現場裁量が大きく創発・適応が起きやすいが統一・調整にコスト。<br/>
                ハイブリッド：中央の方針＋現場裁量で効率と柔軟性の両立を狙う。
              </span>
            </span>
          </h2>
          <div class="legend">
            <span class="lg"><span class="dot" style="background:#3b82f6"></span>標準</span>
            <span class="lg"><span class="dot" style="background:#ef4444"></span>活用特化</span>
            <span class="lg"><span class="dot" style="background:#10b981"></span>探索特化</span>
            <span class="lg"><span class="dot" style="background:#00b300"></span>成功</span>
          </div>
        </div>
      </div>

      <!-- 統計 -->
      <div class="panel" id="stats">
        <h2>統計情報</h2>
        <div class="stats-grid">
          <div class="stat"><div class="k">時刻[s]</div><div class="v" id="s_time">0.0</div></div>
          <div class="stat"><div class="k">総発生</div><div class="v" id="s_spawned">0</div></div>
          <div class="stat"><div class="k">アクティブ</div><div class="v" id="s_active">0</div></div>
          <div class="stat"><div class="k">成功数</div><div class="v" id="s_success">0</div></div>
          <div class="stat"><div class="k">成功率</div><div class="v" id="s_rate">0.0%</div></div>
          <div class="stat"><div class="k">平均成功時間</div><div class="v" id="s_tmean">-</div></div>
        </div>
      </div>

      <!-- シナリオ編集・比較実行 -->
      <div class="panel" id="editor">
        <h2>シナリオ編集・比較（JSON）
          <span class="tip">?
            <span class="bubble">
              複数のシナリオをJSON配列で記述し、連続実行して結果をCSVで保存できます。<br/>
              各シナリオはパラメータ差分のみでOK（未指定は現行値を継承）。
            </span>
          </span>
        </h2>
        <textarea id="scenarioArea" spellcheck="false">[
  {
    "label": "中央集権強め",
    "centralConv": 0.05,
    "peerAttr": 0.005,
    "exploiterRatio": 0.4,
    "explorerRatio": 0.2
  },
  {
    "label": "分散自律強め",
    "centralConv": 0.01,
    "peerAttr": 0.03,
    "exploiterRatio": 0.2,
    "explorerRatio": 0.5
  },
  {
    "label": "ハイブリッド",
    "centralConv": 0.03,
    "peerAttr": 0.02,
    "exploiterRatio": 0.3,
    "explorerRatio": 0.3
  }
]</textarea>
        <div class="btns">
          <button id="btnScenarioRun">シナリオ連続実行</button>
          <button id="btnScenarioStop" class="secondary">停止</button>
          <button id="btnScenarioSave" class="secondary">シナリオ保存</button>
          <button id="btnScenarioLoad" class="secondary">読込</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // 研究水準のABMコア
    // -----------------------------

    // 物理空間（円錐）の仕様
    const CONE = {
      radius: 20,
      height: 40
    };

    // ランタイム状態
    const state = {
      running: false,
      paused: false,
      headless: false,

      elapsed: 0,
      lastSpawn: 0,
      totalSpawned: 0,
      totalSuccess: 0,

      successTimes: [], // 成功までの時間
      particles: [],
      maxParticles: 1000
    };

    // パラメータ（UIと同期）
    const P = {
      timeScale: 0.10,
      spawnInterval: 0.50,
      batchSize: 5,

      initialParticles: 50,

      exploiterRatio: 0.30,
      explorerRatio: 0.30,
      strategicSpawn: true,

      trtForce: 0.015,
      praForce: 0.020,
      praDiversity: 1.00,

      centralConv: 0.030,
      peerAttr: 0.010,

      successTh: 38,
      attrition: 0.020
    };

    // 種別
    const T = { STD: "standard", EXPLOITER: "exploiter", EXPLORER: "explorer" };

    // three.js 初期化
    const stageEl = document.getElementById("stage");
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    stageEl.appendChild(renderer.domElement);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f8f8);
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    camera.position.set(50, 40, 60);
    camera.lookAt(0, 15, 0);

    const amb = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(50,100,50);
    scene.add(dir);

    // 地面
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(240, 240),
      new THREE.MeshPhongMaterial({ color: 0xeeeeee, side: THREE.DoubleSide })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // 円錐の外形（側線なし）：底面円＋頂点マーカーのみ
    const coneGroup = new THREE.Group();
    scene.add(coneGroup);

    function buildConeOutline() {
      coneGroup.clear();
      // 底面円
      const segments = 96;
      const circleGeom = new THREE.BufferGeometry();
      const circlePos = [];
      for (let i=0;i<=segments;i++){
        const a = (i/segments)*Math.PI*2;
        circlePos.push(Math.cos(a)*CONE.radius, 0.01, Math.sin(a)*CONE.radius);
      }
      circleGeom.setAttribute("position", new THREE.Float32BufferAttribute(circlePos,3));
      const circle = new THREE.Line(
        circleGeom,
        new THREE.LineBasicMaterial({ color: 0x999999 })
      );
      coneGroup.add(circle);

      // 頂点（小球）
      const apex = new THREE.Mesh(
        new THREE.SphereGeometry(0.7, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x777777 })
      );
      apex.position.set(0, CONE.height, 0);
      coneGroup.add(apex);

      // 高さ目盛り（任意）
      const tickMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
      for (let h=10; h<CONE.height; h+=10){
        const r = CONE.radius * (1 - h/CONE.height);
        const g = new THREE.BufferGeometry();
        const pos = [];
        for (let i=0;i<=64;i++){
          const a = (i/64)*Math.PI*2;
          pos.push(Math.cos(a)*r, h, Math.sin(a)*r);
        }
        g.setAttribute("position", new THREE.Float32BufferAttribute(pos,3));
        const ring = new THREE.Line(g, tickMat);
        coneGroup.add(ring);
      }
    }
    buildConeOutline();

    // リサイズ
    function resize(){
      const w = stageEl.clientWidth;
      const h = stageEl.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // メッシュ基本形状
    const geoStd = new THREE.SphereGeometry(0.5, 16, 16);
    const geoExpl = new THREE.BoxGeometry(0.8, 0.8, 0.8);
    const geoExpr = new THREE.ConeGeometry(0.6, 1.0, 16);

    // ユーティリティ
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function randn(){ // 簡易正規乱数
      let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
    }

    // 粒子クラス
    class Particle {
      constructor(now){
        // 種別
        const r = Math.random();
        if (r < P.exploiterRatio) this.type = T.EXPLOITER;
        else if (r < P.exploiterRatio + P.explorerRatio) this.type = T.EXPLORER;
        else this.type = T.STD;

        // 個性（親和性）
        const v = (Math.random() - 0.5)*2;
        this.trtAffinity = 1 + 0.6*v*(this.type===T.EXPLOITER?+1:-1);
        this.praAffinity = 1 + 0.6*v*(this.type===T.EXPLORER?+1:-1);

        // 初期位置
        this.pos = new THREE.Vector3(0, 0.5, 0);
        this.vel = new THREE.Vector3( (Math.random()-0.5)*0.03, 0.01, (Math.random()-0.5)*0.03 );
        this.birth = now;
        this.dead = false;
        this.succeeded = false;

        this.spawnStrategic();

        // メッシュ
        let geo, col;
        if (this.type===T.EXPLOITER){ geo = geoExpl; col = 0xef4444; }
        else if (this.type===T.EXPLORER){ geo = geoExpr; col = 0x10b981; }
        else { geo = geoStd; col = 0x3b82f6; }
        const mat = new THREE.MeshPhongMaterial({ color: col });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(this.pos);
        scene.add(this.mesh);
      }

      spawnStrategic(){
        const rU = CONE.radius;
        if (!P.strategicSpawn){
          const a = Math.random()*Math.PI*2;
          const r = Math.random()*rU*0.95;
          this.pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
          return;
        }
        if (this.type===T.EXPLOITER){
          // 中央寄り / 既存成功点近傍に出やすい
          if (state.successTimes.length>0 && Math.random()<0.6){
            // 成功点履歴から近傍生成（粗近似：中心周辺）
            const a = Math.random()*Math.PI*2;
            const rr = Math.random()*6;
            this.pos.set(Math.cos(a)*rr, 0.5, Math.sin(a)*rr);
          } else {
            const a = Math.random()*Math.PI*2;
            const r = Math.random()*rU*0.45;
            this.pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
          }
        } else if (this.type===T.EXPLORER){
          // 周縁部
          const a = Math.random()*Math.PI*2;
          const r = rU*(0.65 + Math.random()*0.35);
          this.pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
        } else {
          const a = Math.random()*Math.PI*2;
          const r = Math.random()*rU*0.90;
          this.pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
        }
      }

      update(dt){
        if (this.dead || this.succeeded) return;

        // 高さ比
        const hRatio = clamp(this.pos.y / CONE.height, 0, 1);

        // TRT：決定論的上昇（低高度で強い）
        const trt = P.trtForce * this.trtAffinity * (1 - hRatio);
        this.vel.y += trt * dt;

        // PRA：確率的水平探索（高度スケール）
        const praSigma = P.praForce * this.praAffinity * (0.4 + 1.2*hRatio) * P.praDiversity;
        const dx = (Math.random()-0.5)*2 * praSigma;
        const dz = (Math.random()-0.5)*2 * praSigma;
        this.vel.x += dx * dt;
        this.vel.z += dz * dt;

        // 中央収束（求心力）
        const toCenter = new THREE.Vector3(-this.pos.x, 0, -this.pos.z);
        if (toCenter.lengthSq()>1e-6){
          toCenter.normalize().multiplyScalar(P.centralConv*dt);
          this.vel.add(toCenter);
        }

        // 粒子間の緩い引力（近接）
        if (P.peerAttr>0 && state.particles.length>1){
          // 近傍数を限定して計算量削減
          for (let k=0, lim=Math.min(8, state.particles.length); k<lim; k++){
            const j = (Math.random()*state.particles.length)|0;
            const q = state.particles[j];
            if (q===this || q.dead || q.succeeded) continue;
            const d = q.pos.clone().sub(this.pos);
            const dd = d.length();
            if (dd>0.1 && dd<4){
              d.normalize().multiplyScalar(P.peerAttr * (1.0/(dd+0.2)) * dt);
              this.vel.add(d);
            }
          }
        }

        // 速度減衰
        this.vel.multiplyScalar(0.985);

        // 位置更新
        this.pos.add(this.vel.clone().multiplyScalar(10*dt));

        // 円錐内拘束（半径は高さにより線形縮小）
        const rMax = CONE.radius * (1 - clamp(this.pos.y / CONE.height, 0, 1));
        const rNow = Math.hypot(this.pos.x, this.pos.z);
        if (rNow > rMax){
          const f = (rNow>0) ? (rMax/rNow) : 0;
          this.pos.x *= f;
          this.pos.z *= f;
          this.vel.x *= 0.5;
          this.vel.z *= 0.5;
        }
        if (this.pos.y < 0.2){ this.pos.y = 0.2; this.vel.y = Math.abs(this.vel.y)*0.2; }

        // 成功判定
        if (this.pos.y >= P.successTh){
          this.succeeded = true;
          state.totalSuccess++;
          state.successTimes.push(state.elapsed - this.birth);
          // 色変更
          this.mesh.material.color.set(0x00b300);
        }

        // 減耗
        if (!this.succeeded && Math.random()< (P.attrition*dt)){
          this.dead = true;
          scene.remove(this.mesh);
        }

        // メッシュ反映
        this.mesh.position.copy(this.pos);
        // 高度で色を僅かに変化
        const hue = 0.60 - 0.45*hRatio; // 青→緑系
        this.mesh.material.color.setHSL(hue, 0.80, 0.55);
      }
    }

    // スポーン
    function spawn(n){
      const room = Math.max(0, state.maxParticles - state.particles.length);
      n = Math.min(n, room);
      for (let i=0;i<n;i++){
        const p = new Particle(state.elapsed);
        state.particles.push(p);
        state.totalSpawned++;
      }
    }

    // リセット
    function reset(){
      // 既存粒子除去
      for (const p of state.particles){
        if (p.mesh) scene.remove(p.mesh);
      }
      state.particles.length = 0;
      state.elapsed = 0;
      state.lastSpawn = 0;
      state.totalSpawned = 0;
      state.totalSuccess = 0;
      state.successTimes.length = 0;
      state.maxParticles = parseInt(document.getElementById("maxParticles").value, 10) || 1000;

      spawn(parseInt(document.getElementById("initialParticles").value, 10) || 0);
    }

    // CSVエクスポート（集計）
    function exportCSV(){
      // 1秒毎のスナップショットを保持していた場合ここで書き出すが、
      // 簡易に最終統計を書き出し
      const rate = (state.totalSpawned>0)? (100*state.totalSuccess/state.totalSpawned):0;
      const mean = (state.successTimes.length>0)? (state.successTimes.reduce((a,b)=>a+b,0)/state.successTimes.length):NaN;
      const rows = [
        ["elapsed_s","spawned","success","success_rate_%","mean_success_time_s"],
        [state.elapsed.toFixed(3), state.totalSpawned, state.totalSuccess, rate.toFixed(3), isNaN(mean)?"":mean.toFixed(3)]
      ];
      const csv = rows.map(r=>r.join(",")).join("\n");
      const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "abm_summary.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // レンダリングループ
    let lastTime = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      if (!state.running || state.paused) {
        renderer.render(scene, camera);
        return;
      }
      const dtReal = (now - lastTime)/1000;
      lastTime = now;
      const dt = dtReal * P.timeScale;

      state.elapsed += dt;

      // 発生
      if (state.elapsed - state.lastSpawn > P.spawnInterval){
        spawn(P.batchSize);
        state.lastSpawn = state.elapsed;
      }

      // 更新
      for (const p of state.particles) p.update(dt);
      // ゴミ取り
      for (let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        if (p.dead){
          state.particles.splice(i,1);
        }
      }

      // 描画
      if (!state.headless) renderer.render(scene, camera);

      // 統計更新
      updateStatsView();
    }

    function updateStatsView(){
      document.getElementById("s_time").textContent = state.elapsed.toFixed(1);
      document.getElementById("s_spawned").textContent = state.totalSpawned;
      const active = state.particles.filter(p=>!p.dead && !p.succeeded).length;
      document.getElementById("s_active").textContent = active;
      document.getElementById("s_success").textContent = state.totalSuccess;
      const rate = (state.totalSpawned>0)? (100*state.totalSuccess/state.totalSpawned):0;
      document.getElementById("s_rate").textContent = rate.toFixed(1) + "%";
      const mean = (state.successTimes.length>0)? (state.successTimes.reduce((a,b)=>a+b,0)/state.successTimes.length):NaN;
      document.getElementById("s_tmean").textContent = isNaN(mean)?"-":mean.toFixed(2)+"s";
    }

    // -----------------------------
    // UIバインド
    // -----------------------------
    function bindRange(id, key, fmt= (v)=>v.toFixed(2)){
      const r = document.getElementById(id);
      const v = document.getElementById("v_"+id) || document.getElementById("v_"+key);
      const apply = ()=>{
        let val = parseFloat(r.value);
        P[key] = val;
        if (v) v.textContent = fmt(val);
      };
      r.addEventListener("input", apply);
      apply();
    }

    bindRange("timeScale","timeScale",(v)=>v.toFixed(2));
    bindRange("spawnInterval","spawnInterval",(v)=>v.toFixed(2));
    bindRange("batchSize","batchSize",(v)=>v.toFixed(0));

    bindRange("exploiterRatio","exploiterRatio",(v)=>v.toFixed(2));
    bindRange("explorerRatio","explorerRatio",(v)=>v.toFixed(2));
    document.getElementById("strategicSpawn").addEventListener("change", e=>{ P.strategicSpawn = e.target.checked; });

    bindRange("trtForce","trtForce",(v)=>v.toFixed(3));
    bindRange("praForce","praForce",(v)=>v.toFixed(3));
    bindRange("praDiversity","praDiversity",(v)=>v.toFixed(2));

    bindRange("centralConv","centralConv",(v)=>v.toFixed(3));
    bindRange("peerAttr","peerAttr",(v)=>v.toFixed(3));
    bindRange("successTh","successTh",(v)=>v.toFixed(0));
    bindRange("attrition","attrition",(v)=>v.toFixed(3));

    document.getElementById("btnStart").addEventListener("click", ()=>{
      state.running = true; state.paused = false;
    });
    document.getElementById("btnPause").addEventListener("click", ()=>{
      state.paused = !state.paused;
    });
    document.getElementById("btnReset").addEventListener("click", ()=>{
      reset();
    });
    document.getElementById("btnExport").addEventListener("click", exportCSV);
    document.getElementById("btnHeadless").addEventListener("click", ()=>{
      state.headless = !state.headless;
    });

    // -----------------------------
    // シナリオ編集・比較
    // -----------------------------
    let scenarioAbort = false;

    document.getElementById("btnScenarioSave").addEventListener("click", ()=>{
      localStorage.setItem("abm_scenarios", document.getElementById("scenarioArea").value);
      alert("シナリオを保存しました（ブラウザ LocalStorage）");
    });
    document.getElementById("btnScenarioLoad").addEventListener("click", ()=>{
      const txt = localStorage.getItem("abm_scenarios");
      if (txt) document.getElementById("scenarioArea").value = txt;
      else alert("保存済みシナリオが見つかりません。");
    });
    document.getElementById("btnScenarioStop").addEventListener("click", ()=>{
      scenarioAbort = true;
    });

    document.getElementById("btnScenarioRun").addEventListener("click", async ()=>{
      let scenarios;
      try{
        scenarios = JSON.parse(document.getElementById("scenarioArea").value);
        if (!Array.isArray(scenarios)) throw new Error("配列ではありません");
      }catch(e){
        alert("JSONの形式に誤りがあります: " + e.message);
        return;
      }

      const base = {...P};
      const results = [];
      scenarioAbort = false;

      for (let i=0;i<scenarios.length;i++){
        if (scenarioAbort){ alert("シナリオ実行を中止しました"); break; }
        const s = scenarios[i] || {};
        // パラメータ適用（差分）
        Object.assign(P, base, s);

        // UI表示を反映（主パラメータのみ同期）
        syncUIFromParams();

        // リセット＆実行（固定時間回す）
        reset();
        state.running = true;
        state.paused = false;

        const simSeconds = s.simSeconds ?? 60; // 既定60秒
        const t0 = state.elapsed;
        const tStartWall = performance.now();
        while ((state.elapsed - t0) < simSeconds){
          // 1フレーム待機
          await new Promise(r=>setTimeout(r, 10));
          if (scenarioAbort) break;
        }
        state.running = false;

        const rate = (state.totalSpawned>0)? (100*state.totalSuccess/state.totalSpawned):0;
        const mean = (state.successTimes.length>0)? (state.successTimes.reduce((a,b)=>a+b,0)/state.successTimes.length):NaN;

        results.push({
          label: s.label ?? ("scenario_"+(i+1)),
          simSeconds,
          spawned: state.totalSpawned,
          success: state.totalSuccess,
          successRate: rate,
          meanSuccessTime: isNaN(mean)? null : mean
        });
      }

      // CSV出力
      if (results.length>0){
        const head = ["label","simSeconds","spawned","success","successRate(%)","meanSuccessTime(s)"];
        const rows = [head].concat(results.map(r=>[
          r.label, r.simSeconds, r.spawned, r.success,
          r.successRate?.toFixed(3),
          (r.meanSuccessTime==null)?"":r.meanSuccessTime.toFixed(3)
        ]));
        const csv = rows.map(r=>r.join(",")).join("\n");
        const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "abm_scenario_results.csv";
        a.click();
        URL.revokeObjectURL(a.href);
        alert("シナリオ比較のCSVを保存しました");
      }

      // 元のパラメータに戻す
      Object.assign(P, base);
      syncUIFromParams();
      reset();
    });

    function syncUIFromParams(){
      const set = (id,val,fmt)=>{ const el=document.getElementById(id); if(el){ el.value=val; } const v=document.getElementById("v_"+id); if(v){ v.textContent = fmt?fmt(val):val; } };
      set("timeScale",P.timeScale,(v)=>v.toFixed(2));
      set("spawnInterval",P.spawnInterval,(v)=>v.toFixed(2));
      set("batchSize",P.batchSize,(v)=>v.toFixed(0));
      set("exploiterRatio",P.exploiterRatio,(v)=>v.toFixed(2));
      set("explorerRatio",P.explorerRatio,(v)=>v.toFixed(2));
      document.getElementById("strategicSpawn").checked = P.strategicSpawn;
      set("trtForce",P.trtForce,(v)=>v.toFixed(3));
      set("praForce",P.praForce,(v)=>v.toFixed(3));
      set("praDiversity",P.praDiversity,(v)=>v.toFixed(2));
      set("centralConv",P.centralConv,(v)=>v.toFixed(3));
      set("peerAttr",P.peerAttr,(v)=>v.toFixed(3));
      set("successTh",P.successTh,(v)=>v.toFixed(0));
      set("attrition",P.attrition,(v)=>v.toFixed(3));
    }

    // 初期化
    reset();
    requestAnimationFrame(loop);

    // 余談：花火エフェクトは本実装に含めていません（ポストプロセスや派手なパーティクルは未使用）
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TRT・PRAシミュレータ v6.0 (ABM研究用拡張・花火なし)</title>
  <!-- 依存は three.js のみ。CDNは固定版 r128 を利用 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root{
      --panel-bg:#ffffff;--panel-shadow:0 4px 20px rgba(0,0,0,0.12);
      --panel-br:#e5e7eb;--ink:#1f2937;--ink2:#374151;--muted:#6b7280;
      --brand:#3b82f6;--brand-2:#2563eb;--bg:#f0f2f5;
    }
    html,body{margin:0;height:100%;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink)}
    /* 2カラム：左=3D、右=パネル群（重なり解消） */
    #main{
      display:flex;flex-direction:row;height:100vh;width:100vw;box-sizing:border-box;overflow:hidden;
    }
    #viewport{
      flex:1 1 auto;min-width:0;min-height:0;position:relative;display:flex;flex-direction:column;
    }
    #canvas-wrap{flex:1 1 auto;min-height:0;position:relative}
    #hud{
      position:absolute;top:10px;left:10px;display:flex;gap:8px;z-index:10;pointer-events:none
    }
    .hud-pill{
      pointer-events:auto;
      background:rgba(255,255,255,0.95);backdrop-filter:saturate(120%) blur(6px);
      border:1px solid var(--panel-br);border-radius:999px;padding:6px 10px;box-shadow:var(--panel-shadow);
      font-size:12px;color:var(--ink2)
    }
    /* 右パネル列（縦並び、スクロール） */
    #side{
      flex:0 0 380px;min-width:300px;max-width:42vw;height:100%;
      overflow:auto;background:#f8fafb;border-left:1px solid var(--panel-br);
      display:flex;flex-direction:column;gap:12px;padding:12px
    }
    .panel{
      background:var(--panel-bg);border:1px solid var(--panel-br);
      border-radius:12px;box-shadow:var(--panel-shadow);padding:14px
    }
    h1{font-size:18px;margin:0 0 8px;color:var(--ink)}
    h2{font-size:14px;margin:14px 0 8px;padding-bottom:6px;border-bottom:1px solid var(--panel-br);color:var(--ink2)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .kv{display:flex;justify-content:space-between;align-items:center;margin:6px 0;font-size:12px;color:var(--ink2)}
    .kv input[type="range"]{width:100%}
    .kv .val{color:var(--muted);min-width:48px;text-align:right}
    .btn{appearance:none;border:1px solid var(--panel-br);background:var(--brand);color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer}
    .btn.secondary{background:#fff;color:var(--ink);border-color:#d1d5db}
    .btn:hover{background:var(--brand-2);color:#fff;border-color:transparent}
    .btn.secondary:hover{background:#f3f4f6}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    textarea{width:100%;min-height:120px;resize:vertical;border:1px solid var(--panel-br);border-radius:8px;padding:8px;font-size:12px}
    .muted{color:var(--muted);font-size:12px}
    .badge{display:inline-flex;align-items:center;gap:6px;background:#eef2ff;border:1px solid #c7d2fe;color:#3730a3;border-radius:999px;padding:4px 8px;font-size:11px}
    .legend-item{display:flex;gap:8px;align-items:center;font-size:12px;margin:6px 0}
    .swatch{width:16px;height:16px;border-radius:50%}
    .tooltip{position:relative;cursor:help}
    .tooltip .tip{
      position:absolute;left:0;top:calc(100% + 6px);min-width:240px;max-width:min(72vw,360px);z-index:20;
      background:#111827;color:#f9fafb;border-radius:8px;padding:10px;border:1px solid #374151;box-shadow:var(--panel-shadow);
      font-size:12px;line-height:1.45;display:none
    }
    .tooltip:hover .tip{display:block}
    /* スマホ/タブレットは縦積みで重なりゼロ */
    @media (max-width: 1024px){
      #main{flex-direction:column;height:auto;min-height:100vh}
      #viewport{height:48vh}
      #side{max-width:100%;width:100%;height:auto}
    }
  </style>
</head>
<body>
  <div id="main">
    <div id="viewport">
      <div id="canvas-wrap"></div>
      <div id="hud">
        <div class="hud-pill"><span>状態: </span><span id="hud-state">停止</span></div>
        <div class="hud-pill"><span>経過: </span><span id="hud-time">0.0s</span></div>
        <div class="hud-pill"><span>成功: </span><span id="hud-succ">0</span></div>
        <div class="hud-pill"><span>総発生: </span><span id="hud-spawn">0</span></div>
        <div class="hud-pill"><span>成功率: </span><span id="hud-rate">0.0%</span></div>
      </div>
    </div>
    <aside id="side">
      <div class="panel">
        <h1>TRT・PRA シミュレータ v6.0</h1>
        <div class="row">
          <button class="btn" id="btn-start">開始</button>
          <button class="btn secondary" id="btn-pause">一時停止</button>
          <button class="btn secondary" id="btn-reset">リセット</button>
          <button class="btn secondary" id="btn-step">1ステップ</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn secondary" id="btn-download-csv">CSVダウンロード</button>
          <button class="btn secondary" id="btn-screenshot">スクリーンショット</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="badge">花火エフェクト: 無効（描画負荷削減）</span>
        </div>
      </div>

      <div class="panel">
        <h2>組織モデル プリセット
          <span class="tooltip">❓
            <span class="tip">
              中央集権型: 中央方針への収束を強め、水平協働を弱める（効率/統一性）．<br>
              分散自律型: 資源間の引力と多様性探索を強める（創発/適応）．<br>
              ハイブリッド: 中央ベクトルを維持しつつ自律協働を許容（両利き）．
            </span>
          </span>
        </h2>
        <div class="grid2">
          <button class="btn secondary" id="preset-central">中央集権型</button>
          <button class="btn secondary" id="preset-decen">分散自律型</button>
          <button class="btn secondary" id="preset-hybrid">ハイブリッド</button>
          <button class="btn secondary" id="preset-emergent">創発重視</button>
        </div>
      </div>

      <div class="panel">
        <h2>資源特性・動学</h2>
        <div class="kv">
          <span>資源異質性</span>
          <span class="val" id="v-hetero">0.5</span>
        </div>
        <input type="range" id="heterogeneity" min="0" max="1" step="0.05" value="0.5" />
        <div class="kv">
          <span>寿命変動</span>
          <span class="val" id="v-lifeVar">0.30</span>
        </div>
        <input type="range" id="lifespanVariance" min="0" max="1" step="0.05" value="0.3" />
        <div class="kv">
          <span>活用特化 割合</span>
          <span class="val" id="v-expR">0.30</span>
        </div>
        <input type="range" id="exploiterRatio" min="0" max="1" step="0.05" value="0.3" />
        <div class="kv">
          <span>探索特化 割合</span>
          <span class="val" id="v-explR">0.30</span>
        </div>
        <input type="range" id="explorerRatio" min="0" max="1" step="0.05" value="0.3" />
        <div class="kv">
          <span>戦略的初期配置</span>
          <input type="checkbox" id="strategicSpawningEnabled" checked />
        </div>
      </div>

      <div class="panel">
        <h2>TRT / PRA</h2>
        <div class="kv"><span>TRT強度</span><span class="val" id="v-trt">0.015</span></div>
        <input type="range" id="trtForce" min="0" max="0.05" step="0.001" value="0.015" />
        <div class="kv"><span>PRA強度</span><span class="val" id="v-pra">0.020</span></div>
        <input type="range" id="praForce" min="0" max="0.05" step="0.001" value="0.02" />
      </div>

      <div class="panel">
        <h2>多重重力・環境</h2>
        <div class="kv"><span>中央収束力</span><span class="val" id="v-cc">0.030</span></div>
        <input type="range" id="centralConvergence" min="0" max="0.1" step="0.001" value="0.03" />
        <div class="kv"><span>粒子引力</span><span class="val" id="v-peer">0.010</span></div>
        <input type="range" id="peerAttraction" min="0" max="0.05" step="0.001" value="0.01" />
        <div class="kv"><span>成功閾値（高さ）</span><span class="val" id="v-th">38</span></div>
        <input type="range" id="successThreshold" min="10" max="60" step="1" value="38" />
        <div class="kv"><span>減耗率</span><span class="val" id="v-attrit">0.020</span></div>
        <input type="range" id="attritionRate" min="0" max="0.1" step="0.001" value="0.02" />
      </div>

      <div class="panel">
        <h2>実験・再現性</h2>
        <div class="grid2">
          <div class="kv" style="grid-column:1/-1">
            <span>シード</span>
            <input type="number" id="seed" class="mono" value="12345" style="width:120px" />
          </div>
          <div class="kv" style="grid-column:1/-1">
            <span>初期発生数</span>
            <input type="number" id="initialParticles" value="20" style="width:100px" />
          </div>
          <div class="kv" style="grid-column:1/-1">
            <span>バッチ発生間隔[s]</span>
            <input type="number" id="spawnInterval" step="0.1" value="0.5" style="width:100px" />
          </div>
          <div class="kv" style="grid-column:1/-1">
            <span>バッチサイズ</span>
            <input type="number" id="batchSize" value="3" style="width:100px" />
          </div>
          <div class="kv" style="grid-column:1/-1">
            <span>時間スケール</span>
            <input type="number" id="timeScale" step="0.01" value="0.10" style="width:100px" />
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn secondary" id="btn-headless-10">ヘッドレス×10回</button>
          <button class="btn secondary" id="btn-headless-100">ヘッドレス×100回</button>
        </div>
        <div class="muted" style="margin-top:6px">
          ヘッドレスは描画を止めて統計のみ更新（CSVへ累積）．乱数はシードで再現可能．
        </div>
      </div>

      <div class="panel">
        <h2>シナリオ編集</h2>
        <div class="row" style="gap:6px;margin-bottom:6px">
          <button class="btn secondary" id="btn-scn-load">読込</button>
          <button class="btn secondary" id="btn-scn-save">保存</button>
          <button class="btn secondary" id="btn-scn-apply">適用</button>
        </div>
        <textarea id="scenario" class="mono" spellcheck="false" placeholder='{
  "name":"baseline",
  "parameters":{
    "trtForce":0.015,"praForce":0.02,"centralConvergence":0.03,
    "peerAttraction":0.01,"heterogeneity":0.5,"lifespanVariance":0.3,
    "exploiterRatio":0.3,"explorerRatio":0.3,"strategicSpawningEnabled":true,
    "successThreshold":38,"attritionRate":0.02
  }
}'></textarea>
        <div class="muted">ブラウザのローカルストレージへ保存/読込．研究用に複数条件を管理可能．</div>
      </div>

      <div class="panel">
        <h2>凡例</h2>
        <div class="legend-item"><span class="swatch" style="background:#3b82f6"></span>標準型</div>
        <div class="legend-item"><span class="swatch" style="background:#ef4444"></span>活用特化型</div>
        <div class="legend-item"><span class="swatch" style="background:#10b981"></span>探索特化型</div>
        <div class="legend-item"><span class="swatch" style="background:#22c55e"></span>成功</div>
      </div>
    </aside>
  </div>

  <script>
    // ================ 乱数（再現性のためのシード付き） ===================
    function XorShift(seed=123456789){
      let x = seed|0, y=362436069, z=521288629, w=88675123;
      return function rand(){
        const t = x ^ (x << 11);
        x = y; y = z; z = w;
        w = (w ^ (w >>> 19)) ^ (t ^ (t >>> 8));
        return (w >>> 0) / 0x100000000;
      };
    }
    let rand = XorShift(12345);

    // ================ Three.js 基本セットアップ（描画のみ） ================
    const canvasWrap = document.getElementById('canvas-wrap');
    const renderer = new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});
    renderer.setSize(canvasWrap.clientWidth, canvasWrap.clientHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    canvasWrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8f8f8);

    const camera = new THREE.PerspectiveCamera(60, canvasWrap.clientWidth/canvasWrap.clientHeight, 0.1, 1000);
    camera.position.set(50,40,60);
    camera.lookAt(0,15,0);

    const amb = new THREE.AmbientLight(0xffffff,0.7); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(50,100,50); dir.castShadow = true; scene.add(dir);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshPhongMaterial({color:0xe5e7eb,side:THREE.DoubleSide}));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    window.addEventListener('resize', ()=>{
      const w = canvasWrap.clientWidth || window.innerWidth;
      const h = canvasWrap.clientHeight || Math.max(320, window.innerHeight*0.5);
      renderer.setSize(w,h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    });

    // ================ ABM モデル・状態 =========================
    const State = {
      isRunning:false, isPaused:false, elapsed:0, lastSpawn:0,
      totalSpawned:0, successCount:0, agents:[], logs:[],
      clusters:[] // 簡易：本実装では未使用（将来拡張用）
    };

    const Params = {
      timeScale:0.10, spawnInterval:0.5, batchSize:3, initialParticles:20,
      heterogeneity:0.5, lifespanVariance:0.3,
      exploiterRatio:0.3, explorerRatio:0.3, strategicSpawningEnabled:true,
      trtForce:0.015, praForce:0.02, centralConvergence:0.03, peerAttraction:0.01,
      successThreshold:38, attritionRate:0.02
    };

    // UI同期
    const bindSlider = (id, valId, objKey, fmt=(v)=>v.toFixed(3))=>{
      const el = document.getElementById(id);
      const v  = document.getElementById(valId);
      if(!el) return;
      const update = ()=>{
        let val = (el.type==='checkbox') ? el.checked : parseFloat(el.value);
        Params[objKey] = val;
        if(v) v.textContent = (el.type==='checkbox') ? (val?'ON':'OFF') : (objKey==='successThreshold' ? val.toFixed(0) : fmt(val));
      };
      el.addEventListener('input', update);
      update();
    };
    bindSlider('heterogeneity','v-hetero','heterogeneity',(v)=>v.toFixed(2));
    bindSlider('lifespanVariance','v-lifeVar','lifespanVariance',(v)=>v.toFixed(2));
    bindSlider('exploiterRatio','v-expR','exploiterRatio',(v)=>v.toFixed(2));
    bindSlider('explorerRatio','v-explR','explorerRatio',(v)=>v.toFixed(2));
    bindSlider('trtForce','v-trt','trtForce');
    bindSlider('praForce','v-pra','praForce');
    bindSlider('centralConvergence','v-cc','centralConvergence');
    bindSlider('peerAttraction','v-peer','peerAttraction');
    bindSlider('successThreshold','v-th','successThreshold',(v)=>v.toFixed(0));
    bindSlider('attritionRate','v-attrit','attritionRate');

    // ================ エージェント =========================
    const TYPE = {STD:0, EXPLOITER:1, EXPLORER:2};
    const coneHeight = 40, coneRadius = 20;

    function typeFromRatios(){
      const r = rand();
      if(r < Params.exploiterRatio) return TYPE.EXPLOITER;
      if(r < Params.exploiterRatio + Params.explorerRatio) return TYPE.EXPLORER;
      return TYPE.STD;
    }

    function makeAgent(){
      const type = typeFromRatios();
      const baseColor = (type===TYPE.STD)?0x3b82f6:(type===TYPE.EXPLOITER?0xef4444:0x10b981);
      const geo = (type===TYPE.STD)?new THREE.SphereGeometry(0.5,16,16)
                 :(type===TYPE.EXPLOITER?new THREE.BoxGeometry(0.8,0.8,0.8):new THREE.ConeGeometry(0.5,1,16));
      const mat = new THREE.MeshPhongMaterial({color:baseColor});
      const mesh = new THREE.Mesh(geo,mat); mesh.castShadow = true;

      // 異質性に基づく親和性
      const variance = (rand()-0.5)*2*Params.heterogeneity;
      let trtAffinity=1, praAffinity=1;
      if(type===TYPE.EXPLOITER){ trtAffinity += Math.abs(variance); praAffinity -= Math.abs(variance)*0.5; }
      else if(type===TYPE.EXPLORER){ praAffinity += Math.abs(variance); trtAffinity -= Math.abs(variance)*0.5; }
      else { trtAffinity += variance*0.25; praAffinity += -variance*0.25; }

      // 初期配置
      let pos = new THREE.Vector3(0,0.5,0);
      if(Params.strategicSpawningEnabled){
        if(type===TYPE.EXPLOITER){
          const a = rand()*Math.PI*2, r = rand()*coneRadius*0.4;
          pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
        }else if(type===TYPE.EXPLORER){
          const a = rand()*Math.PI*2, r = coneRadius*(0.6 + 0.4*rand());
          pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
        }else{
          const a = rand()*Math.PI*2, r = rand()*coneRadius*0.9;
          pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
        }
      }else{
        const a = rand()*Math.PI*2, r = rand()*coneRadius*0.9;
        pos.set(Math.cos(a)*r, 0.5, Math.sin(a)*r);
      }
      mesh.position.copy(pos); scene.add(mesh);

      return {
        type, mesh,
        pos, vel:new THREE.Vector3((rand()-0.5)*0.05,(rand()*0.02)+0.01,(rand()-0.5)*0.05),
        age:0, alive:true, succeeded:false,
        trtAffinity, praAffinity,
        maxAge: 60 + rand()*80 // 寿命は60〜140の範囲（lifespanVarianceは減耗で反映）
      };
    }

    function updateAgent(a, dt){
      if(!a.alive) return;
      const hRatio = a.pos.y / coneHeight;

      // TRT（縦）: 上方向の推進、上ほど減衰
      a.vel.y += Params.trtForce * (1 - hRatio) * a.trtAffinity * dt;

      // PRA（横）: ランダム探索（高さが上がると多様化を強める仮説）
      const pr = Params.praForce * (0.5 + 0.5*hRatio) * a.praAffinity * dt;
      a.vel.x += (rand()-0.5)*2*pr;
      a.vel.z += (rand()-0.5)*2*pr;

      // 中央収束
      const toCenter = new THREE.Vector3(-a.pos.x,0,-a.pos.z).normalize().multiplyScalar(Params.centralConvergence*dt);
      a.vel.add(toCenter);

      // 粒子間引力（簡易：中心回りの渦抑制の微調整としてノイズベクトル）
      const peer = Params.peerAttraction*dt;
      a.vel.x += (rand()-0.5)*2*peer*0.2;
      a.vel.z += (rand()-0.5)*2*peer*0.2;

      // 速度減衰と位置反映
      a.pos.add(a.vel.clone().multiplyScalar(dt*10));
      a.vel.multiplyScalar(0.985);

      // 円錐境界
      const rNow = Math.hypot(a.pos.x,a.pos.z);
      const rMax = Math.max(0, coneRadius * (1 - a.pos.y/coneHeight));
      if(rNow > rMax){
        const s = rMax / rNow;
        a.pos.x *= s; a.pos.z *= s;
      }
      if(a.pos.y < 0){ a.pos.y = 0; a.vel.y = Math.abs(a.vel.y)*0.5; }

      // 成功判定
      if(a.pos.y*1.0 >= Params.successThreshold && !a.succeeded){
        a.succeeded = true; a.alive = false; State.successCount++;
        a.mesh.material.color.set(0x22c55e);
      }

      // 減耗・寿命
      a.age += dt;
      const hazard = Params.attritionRate * (1 + Params.lifespanVariance*(a.age/a.maxAge));
      if(a.age> a.maxAge || rand() < hazard*dt){ // 単位時間あたり確率
        // 死亡
        a.alive = false;
      }

      // 反映
      a.mesh.position.copy(a.pos);
      a.mesh.material.emissive = new THREE.Color(0x000000);
    }

    // ================ 生成・リセット・HUD =========================
    function spawn(n){
      for(let i=0;i<n;i++){
        if(State.agents.length>800) break;
        const a = makeAgent();
        State.agents.push(a);
        State.totalSpawned++;
      }
    }
    function clearScene(){
      State.agents.forEach(a=>{ if(a.mesh) scene.remove(a.mesh); });
      State.agents = [];
    }
    function reset(){
      clearScene();
      State.elapsed=0; State.lastSpawn=0; State.totalSpawned=0; State.successCount=0; State.logs=[];
      spawn(Number(document.getElementById('initialParticles').value||20));
      updateHud();
    }
    function updateHud(){
      document.getElementById('hud-state').textContent = State.isRunning ? (State.isPaused?'一時停止':'実行中') : '停止';
      document.getElementById('hud-time').textContent = State.elapsed.toFixed(1)+'s';
      document.getElementById('hud-succ').textContent = State.successCount;
      document.getElementById('hud-spawn').textContent = State.totalSpawned;
      const rate = State.totalSpawned? (100*State.successCount/State.totalSpawned):0;
      document.getElementById('hud-rate').textContent = rate.toFixed(1)+'%';
    }

    // ================ ループ =========================
    let lastT = 0;
    function loop(t){
      requestAnimationFrame(loop);
      const dtReal = (t - lastT)*0.001; lastT = t;
      const timeScale = Number(document.getElementById('timeScale').value||Params.timeScale);
      const dt = Math.max(0, dtReal * timeScale);

      if(State.isRunning && !State.isPaused){
        State.elapsed += dt;
        const sInt = Number(document.getElementById('spawnInterval').value||Params.spawnInterval);
        const bSize= Number(document.getElementById('batchSize').value||Params.batchSize);
        if((State.elapsed - State.lastSpawn) > sInt){
          spawn(bSize);
          State.lastSpawn = State.elapsed;
        }
        State.agents.forEach(a=>updateAgent(a, dt));
        State.agents = State.agents.filter(a=>{
          if(!a.alive && !a.succeeded){ if(a.mesh) scene.remove(a.mesh); return false; }
          if(a.succeeded){ return false; }
          return true;
        });
        // ログ（1秒粒度）
        if(Math.floor(State.elapsed) !== Math.floor(State.elapsed-dt)){
          const rate = State.totalSpawned? (State.successCount/State.totalSpawned):0;
          State.logs.push({t:State.elapsed.toFixed(1), spawn:State.totalSpawned, succ:State.successCount, rate:rate.toFixed(4)});
        }
        updateHud();
      }
      renderer.render(scene,camera);
    }
    requestAnimationFrame(loop);

    // ================ CSV =========================
    function downloadCSV(){
      const header = 'time_s,total_spawned,success_count,success_rate\n';
      const body = State.logs.map(r=>`${r.t},${r.spawn},${r.succ},${r.rate}`).join('\n');
      const blob = new Blob([header+body], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `abm_logs_${Date.now()}.csv`;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // ================ シナリオ保存・読込・適用 =========================
    const LS_KEY = 'trt_pra_scenarios_v1';
    function loadScenarios(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return {};
        return JSON.parse(raw);
      }catch{ return {}; }
    }
    function saveScenarios(obj){
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }
    document.getElementById('btn-scn-save').addEventListener('click', ()=>{
      let obj = loadScenarios();
      try{
        const scn = JSON.parse(document.getElementById('scenario').value);
        if(!scn.name) scn.name = 'unnamed_'+Date.now();
        obj[scn.name] = scn;
        saveScenarios(obj);
        alert('保存しました: '+scn.name);
      }catch(e){
        alert('JSONエラー: '+e.message);
      }
    });
    document.getElementById('btn-scn-load').addEventListener('click', ()=>{
      const obj = loadScenarios();
      const keys = Object.keys(obj);
      if(keys.length===0){ alert('保存されたシナリオがありません'); return; }
      const name = prompt('読込するシナリオ名を入力:\n'+keys.join(', '), keys[0]);
      if(!name || !obj[name]) return;
      document.getElementById('scenario').value = JSON.stringify(obj[name], null, 2);
    });
    document.getElementById('btn-scn-apply').addEventListener('click', ()=>{
      try{
        const scn = JSON.parse(document.getElementById('scenario').value);
        if(scn.parameters){
          Object.assign(Params, scn.parameters);
          // UI反映（主要パラメータのみ）
          const setIf = (id,val)=>{ const el=document.getElementById(id); if(el){ if(el.type==='checkbox') el.checked=!!val; else el.value=val; el.dispatchEvent(new Event('input')); } };
          setIf('trtForce',Params.trtForce);
          setIf('praForce',Params.praForce);
          setIf('centralConvergence',Params.centralConvergence);
          setIf('peerAttraction',Params.peerAttraction);
          setIf('heterogeneity',Params.heterogeneity);
          setIf('lifespanVariance',Params.lifespanVariance);
          setIf('exploiterRatio',Params.exploiterRatio);
          setIf('explorerRatio',Params.explorerRatio);
          setIf('strategicSpawningEnabled',Params.strategicSpawningEnabled);
          setIf('successThreshold',Params.successThreshold);
          setIf('attritionRate',Params.attritionRate);
          alert('適用しました');
        }
      }catch(e){ alert('JSONエラー: '+e.message); }
    });

    // ================ プリセット =========================
    function applyPreset(kind){
      const set = (k,v)=>{ Params[k]=v; const el=document.getElementById(k); if(el){ el.value=v; el.dispatchEvent(new Event('input')); } };
      if(kind==='central'){
        set('centralConvergence',0.06);
        set('peerAttraction',0.002);
        set('trtForce',0.018);
        set('praForce',0.010);
      }else if(kind==='decentral'){
        set('centralConvergence',0.010);
        set('peerAttraction',0.020);
        set('trtForce',0.012);
        set('praForce',0.028);
      }else if(kind==='hybrid'){
        set('centralConvergence',0.030);
        set('peerAttraction',0.014);
        set('trtForce',0.015);
        set('praForce',0.020);
      }else if(kind==='emergent'){
        set('centralConvergence',0.015);
        set('peerAttraction',0.018);
        set('trtForce',0.013);
        set('praForce',0.026);
      }
    }
    document.getElementById('preset-central').addEventListener('click', ()=>applyPreset('central'));
    document.getElementById('preset-decen').addEventListener('click', ()=>applyPreset('decentral'));
    document.getElementById('preset-hybrid').addEventListener('click', ()=>applyPreset('hybrid'));
    document.getElementById('preset-emergent').addEventListener('click', ()=>applyPreset('emergent'));

    // ================ ヘッドレス実行（描画スキップで統計のみ） ============
    function headlessRun(times=10){
      const savedRunning = State.isRunning, savedPaused = State.isPaused;
      State.isRunning = false; State.isPaused = false;
      const savedLogs = State.logs.slice();
      for(let i=0;i<times;i++){
        // 試行ごとにシード前進（再現性＋独立）
        const seedBase = Number(document.getElementById('seed').value||12345);
        rand = XorShift(seedBase + i + Date.now()%1000);
        reset();
        // 仮想時間：最大120秒相当進める
        let simT=0;
        while(simT < 120){
          const dt = 0.05; // 50ms tick
          // 生成タイミング
          const sInt = Number(document.getElementById('spawnInterval').value||Params.spawnInterval);
          const bSize= Number(document.getElementById('batchSize').value||Params.batchSize);
          if((simT - State.lastSpawn) > sInt){
            spawn(bSize);
            State.lastSpawn = simT;
          }
          State.agents.forEach(a=>updateAgent(a, dt));
          State.agents = State.agents.filter(a=>{
            if(!a.alive && !a.succeeded){ if(a.mesh) scene.remove(a.mesh); return false; }
            if(a.succeeded){ return false; }
            return true;
          });
          simT += dt;
          if(Math.floor(simT)!==Math.floor(simT-dt)){
            const rate = State.totalSpawned? (State.successCount/State.totalSpawned):0;
            State.logs.push({t:simT.toFixed(1), spawn:State.totalSpawned, succ:State.successCount, rate:rate.toFixed(4)});
          }
          // 早期終了条件：一定成功数到達 or 全滅
          if(State.successCount>=Math.max(10, Params.initialParticles||20)) break;
          if(State.agents.length===0 && simT>5) break;
        }
      }
      // 描画系の状態を復帰
      State.isRunning = savedRunning; State.isPaused = savedPaused;
      // ログは累積維持
      updateHud();
      alert(`ヘッドレス完了: ${times} 試行。CSVで集計をご確認ください。`);
    }

    // ================ スクショ =========================
    document.getElementById('btn-screenshot').addEventListener('click', ()=>{
      const url = renderer.domElement.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url; a.download='screenshot.png'; a.click();
    });

    // ================ ボタン動作 =========================
    document.getElementById('btn-start').addEventListener('click', ()=>{ State.isRunning=true; State.isPaused=false; updateHud(); });
    document.getElementById('btn-pause').addEventListener('click', ()=>{ State.isPaused=!State.isPaused; updateHud(); });
    document.getElementById('btn-reset').addEventListener('click', ()=>{ reset(); updateHud(); });
    document.getElementById('btn-step').addEventListener('click', ()=>{
      if(!State.isRunning){ State.isRunning=true; State.isPaused=true; }
      // 1フレーム分だけ進める
      State.elapsed += 0.1;
      State.agents.forEach(a=>updateAgent(a, 0.1));
      State.agents = State.agents.filter(a=>{
        if(!a.alive && !a.succeeded){ if(a.mesh) scene.remove(a.mesh); return false; }
        if(a.succeeded){ return false; }
        return true;
      });
      updateHud();
    });
    document.getElementById('btn-download-csv').addEventListener('click', downloadCSV);
    document.getElementById('btn-headless-10').addEventListener('click', ()=>headlessRun(10));
    document.getElementById('btn-headless-100').addEventListener('click', ()=>headlessRun(100));

    // ================ 初期化 =========================
    (function init(){
      // シード適用
      const seedEl = document.getElementById('seed');
      rand = XorShift(Number(seedEl.value||12345));
      seedEl.addEventListener('change', ()=>{ rand = XorShift(Number(seedEl.value||12345)); });

      // 入力ボックスから Params を随時反映
      ['initialParticles','spawnInterval','batchSize','timeScale'].forEach(id=>{
        const el = document.getElementById(id);
        if(!el) return;
        el.addEventListener('change', ()=>{ Params[id] = (id==='initialParticles')? Number(el.value) : Number(el.value); });
        Params[id] = (id==='initialParticles')? Number(el.value) : Number(el.value);
      });

      reset();
    })();
  </script>
</body>
</html>

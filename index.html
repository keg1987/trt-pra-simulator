<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TRT×PRA ABM – Research-Ready (ESM/No-Global)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#60a5fa; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444;
    --bd:#1f2937; --bd2:#334155;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{display:grid;grid-template-columns:360px 1fr;grid-template-rows:100vh}
  #left{background:var(--panel);padding:16px 14px;overflow:auto;box-shadow:2px 0 12px rgba(0,0,0,.35)}
  #right{position:relative}
  h1{font-size:18px;margin:0 0 8px;letter-spacing:.2px}
  h2{font-size:13px;margin:14px 0 6px;color:#cbd5e1}
  fieldset{border:1px solid var(--bd);border-radius:10px;padding:10px 10px 8px;margin:10px 0}
  legend{padding:0 6px;color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 80px;gap:8px;align-items:center;margin:6px 0}
  .row>label{font-size:12px;color:var(--muted)}
  input[type=number],input[type=text]{width:100%;background:#0b1220;border:1px solid var(--bd2);color:var(--text);border-radius:8px;padding:6px 8px}
  .btns{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 2px}
  button{background:#1e293b;color:#e2e8f0;border:1px solid var(--bd2);padding:8px 10px;border-radius:8px;cursor:pointer}
  button:hover{background:#233047}
  button.primary{background:linear-gradient(180deg,#3b82f6,#1d4ed8);border:none}
  button.warn{background:#f59e0b;color:#0b1020;border:none}
  button.ghost{background:transparent;border:1px dashed var(--bd2)}
  .stats{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .stat{background:#0b1220;border:1px solid var(--bd);border-radius:8px;padding:10px}
  .stat h3{margin:0;font-size:12px;color:#94a3b8}
  .stat .v{font-size:16px;margin-top:6px}
  #canvas{width:100%;height:100%;display:block}
  .small{font-size:12px;opacity:.85}
  .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:#0b1220;border:1px solid var(--bd);border-radius:8px;padding:8px;white-space:pre-wrap}
  .sep{height:1px;background:var(--bd);margin:10px 0}
  #toast{position:absolute;left:16px;bottom:16px;max-width:460px}
  .toast{background:#0b1220;border:1px solid var(--bd);border-left:4px solid var(--accent);padding:10px 12px;border-radius:8px;margin-top:8px;font-size:12px}
</style>
</head>
<body>
<div id="app">
  <aside id="left">
    <h1>TRT×PRA ABM <span class="small">Research-Ready（円錐=外形のみ）</span></h1>
    <div class="code">原理：dy = μ(y)·dτ + σ·dW<sub>τ</sub>, &nbsp; dτ = r(u,diversity)·dt</div>

    <fieldset>
      <legend>再現性 / 実行</legend>
      <div class="row"><label>Seed</label><input id="seed" type="number" value="12345"></div>
      <div class="row"><label>試行回数 K</label><input id="trials" type="number" min="1" max="500" value="20"></div>
      <div class="row"><label>dt (秒)</label><input id="dt" type="number" step="0.001" value="0.02"></div>
      <div class="row"><label>T (秒)</label><input id="T" type="number" step="0.1" value="60"></div>
      <div class="btns">
        <button class="primary" id="btnStart">開始</button>
        <button id="btnPause">一時停止</button>
        <button id="btnReset">リセット</button>
        <button class="ghost" id="btnStep">1ステップ</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>環境（円錐空間：外形のみ）</legend>
      <div class="row"><label>高さ H</label><input id="H" type="number" step="1" value="40"></div>
      <div class="row"><label>底面半径 R</label><input id="R" type="number" step="1" value="20"></div>
      <div class="row"><label>成功閾値 y<sub>succ</sub></label><input id="ySucc" type="number" step="0.1" value="38"></div>
      <div class="row"><label>頂点容量 C</label><input id="vertexCap" type="number" step="1" value="6"></div>
      <div class="row"><label>容量半径 r<sub>cap</sub></label><input id="capRadius" type="number" step="0.1" value="2"></div>
      <div class="row"><label>混雑指数 γ (0–2)</label><input id="gammaCong" type="number" step="0.1" value="0.8"></div>
    </fieldset>

    <fieldset>
      <legend>TRT（縦推進）</legend>
      <div class="row"><label>基礎成長 α<sub>0</sub></label><input id="alpha0" type="number" step="0.001" value="0.015"></div>
      <div class="row"><label>ティップ点 y*</label><input id="yStar" type="number" step="0.1" value="28"></div>
      <div class="row"><label>ブースト α<sub>1</sub></label><input id="alpha1" type="number" step="0.01" value="0.5"></div>
      <div class="row"><label>滑らかさ τ<sub>s</sub></label><input id="tauS" type="number" step="0.1" value="1.5"></div>
      <div class="row"><label>市場引力 β<sub>m</sub></label><input id="betaM" type="number" step="0.001" value="0.02"></div>
    </fieldset>

    <fieldset>
      <legend>PRA（水平探索）</legend>
      <div class="row"><label>探索率 u ∈[0,1]</label><input id="uRate" type="number" min="0" max="1" step="0.01" value="0.4"></div>
      <div class="row"><label>拡散 D<sub>0</sub></label><input id="D0" type="number" step="0.001" value="0.02"></div>
      <div class="row"><label>中心収束 κ<sub>c</sub></label><input id="kappaC" type="number" step="0.001" value="0.03"></div>
      <div class="row"><label>近接引力 κ<sub>p</sub></label><input id="kappaP" type="number" step="0.001" value="0.03"></div>
      <div class="row"><label>τ効率 ρ (diversity係数)</label><input id="rhoTau" type="number" step="0.05" value="0.3"></div>
    </fieldset>

    <fieldset>
      <legend>生成/人口</legend>
      <div class="row"><label>初期 N</label><input id="N0" type="number" step="1" value="30"></div>
      <div class="row"><label>バッチ投入 b</label><input id="batch" type="number" step="1" value="3"></div>
      <div class="row"><label>投入間隔 Δt<sub>spawn</sub> (秒)</label><input id="spawnInt" type="number" step="0.1" value="0.8"></div>
    </fieldset>

    <fieldset>
      <legend>クラスタ検出（DBSCAN）</legend>
      <div class="row"><label>ε (eps)</label><input id="eps" type="number" step="0.1" value="3.5"></div>
      <div class="row"><label>MinPts</label><input id="minPts" type="number" step="1" value="3"></div>
      <div class="row"><label>検出間隔(秒)</label><input id="detectInt" type="number" step="0.1" value="0.5"></div>
    </fieldset>

    <div class="btns">
      <button id="btnExportSnapshot">スナップCSV</button>
      <button id="btnExportSummary">サマリCSV</button>
      <button id="btnExportConfig">設定JSON</button>
      <button class="warn" id="btnHeadless">ヘッドレスK試行CSV</button>
    </div>

    <h2>リアルタイム指標</h2>
    <div class="stats">
      <div class="stat"><h3>t（実時間, s）</h3><div class="v" id="stat_t">0.00</div></div>
      <div class="stat"><h3>τ（内生時間）</h3><div class="v" id="stat_tau">0.00</div></div>
      <div class="stat"><h3>成功数</h3><div class="v" id="stat_succ">0</div></div>
      <div class="stat"><h3>成功率</h3><div class="v" id="stat_rate">0.0%</div></div>
      <div class="stat"><h3>アクティブ</h3><div class="v" id="stat_active">0</div></div>
      <div class="stat"><h3>クラスタ数</h3><div class="v" id="stat_clusters">0</div></div>
      <div class="stat"><h3>最大クラスタ</h3><div class="v" id="stat_maxcl">0</div></div>
      <div class="stat"><h3>TDCI(τ)</h3><div class="v" id="stat_tdci">0.000</div></div>
    </div>

    <div class="sep"></div>
    <div class="code" id="logBox" style="max-height:180px">ready.</div>
  </aside>

  <main id="right">
    <canvas id="canvas"></canvas>
    <div id="toast"></div>
  </main>
</div>

<!-- three.js ESM (安定版)。CDNはこの2本のみ。 -->
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

/***  ユーティリティ／RNG  ***/
function mulberry32(seed){ let a=seed>>>0; return function(){ a+=0x6D2B79F5; let t=Math.imul(a^(a>>>15),1|a); t^=t+Math.imul(t^(t>>>7),61|t); return ((t^(t>>>14))>>>0)/4294967296; } }
function gaussian(rng){ let u=0,v=0; while(u===0) u=rng(); while(v===0) v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const smoothStep=(x,tau)=>1/(1+Math.exp(-x/Math.max(1e-6,tau)));
const UI=(sel)=>document.querySelector(sel);
const toast=(msg)=>{ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; UI('#toast').appendChild(t); setTimeout(()=>t.remove(), 4200); };
function download(content, name, mime){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([content],{type:mime})); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); }

/***  角度多様性とTDCI  ***/
function angularDiversity(points, bins=16){
  if(points.length===0) return 0;
  const hist=new Array(bins).fill(0);
  for(const p of points){
    const ang=Math.atan2(p.z,p.x);
    let k=Math.floor(((ang+Math.PI)/(2*Math.PI))*bins); if(k===bins) k=bins-1;
    hist[k]++;
  }
  const N=points.length; let sumsq=0;
  for(const h of hist){ const pr=h/N; sumsq+=pr*pr; }
  return 1 - sumsq; // Simpson
}

/***  空間ハッシュ（DBSCAN & 近接力用）  ***/
class SpatialHash{
  constructor(cell){ this.cell=cell; this.map=new Map(); }
  key(i,j,k){ return `${i}|${j}|${k}`; }
  idx(x,y,z){ return [Math.floor(x/this.cell), Math.floor(y/this.cell), Math.floor(z/this.cell)]; }
  clear(){ this.map.clear(); }
  insert(id, p){ const [i,j,k]=this.idx(p.x,p.y,p.z); const key=this.key(i,j,k); if(!this.map.has(key)) this.map.set(key,[]); this.map.get(key).push(id); }
  query(p, r){ const c=this.cell; const [i0,j0,k0]=this.idx(p.x,p.y,p.z); const L=Math.ceil(r/c); const out=[]; for(let i=-L;i<=L;i++) for(let j=-L;j<=L;j++) for(let k=-L;k<=L;k++){ const arr=this.map.get(this.key(i0+i,j0+j,k0+k)); if(arr) out.push(...arr); } return out; }
}

/***  物理コア（可視化・ヘッドレス共通）  ***/
class ABMCore{
  constructor(params){ this.p={...params}; this.resetState(); }
  resetState(){ this.t=0; this.tau=0; this.lastSpawn=0; this.succ=0; this.totalSpawned=0; this.particles=[]; this.grid=new SpatialHash(this.p.eps); this.tdci=0; this._lam=0.2; this._id=1; }
  radius(y){ const {H,R}=this.p; return R*(1-clamp(y/H,0,1)); }
  timeDensity(u,div){ return Math.max(1e-6, (1-u) * (1 - this.p.rhoTau * div)); } // dτ/dt
  driftY(y){ const {H,alpha0,alpha1,yStar,tauS,betaM,ySucc}=this.p; const rel=1-y/H; const tip=1 + alpha1*smoothStep(yStar - y, tauS); const pull = (y>0.7*H? betaM*(ySucc-y)/Math.max(1, H*0.05):0); return alpha0*rel*tip + pull; }
  randomInitPos(rng){ const r=this.p.R*0.9*Math.sqrt(rng()); const th=2*Math.PI*rng(); return new THREE.Vector3(r*Math.cos(th),1.0,r*Math.sin(th)); }
  spawn(n,rng){ for(let i=0;i<n;i++){ this.particles.push({ id:this._id++, pos:this.randomInitPos(rng), alive:true, succT:null }); } this.totalSpawned+=n; }
  init(rng){ this.particles=[]; this._id=1; this.spawn(this.p.N0,rng); }
  step(dt,rng){
    const P=this.p;
    const act=this.particles.filter(q=>q.alive).map(q=>q.pos);
    const div=angularDiversity(act, 16);
    const dTau=this.timeDensity(P.uRate, div)*dt; // 内生時間
    this.tau+=dTau;

    // 頂点容量混雑
    const apex=new THREE.Vector3(0,P.H,0); let near=0;
    for(const q of this.particles){ if(q.alive && q.pos.distanceTo(apex)<P.capRadius) near++; }
    const cong=Math.pow(Math.min(1, P.vertexCap/Math.max(1,near)), P.gammaCong);

    // 空間ハッシュ更新
    this.grid.clear(); for(const q of this.particles){ if(q.alive) this.grid.insert(q.id, q.pos); }

    const eps2=P.eps*P.eps; const kNN=6;
    for(const q of this.particles){
      if(!q.alive) continue;
      const y=q.pos.y;

      // 縦方向（τ時間でのドリフト、ノイズは0で安定化）
      const muY=this.driftY(y)*cong;
      const dy=muY*dTau;

      // 水平（τ拡散 + 中央収束 + 近接引力）
      const D=P.D0*P.uRate;
      const dxDiff=Math.sqrt(2*D*Math.max(dTau,0))*gaussian(rng);
      const dzDiff=Math.sqrt(2*D*Math.max(dTau,0))*gaussian(rng);
      const cx=-P.kappaC*q.pos.x*dTau, cz=-P.kappaC*q.pos.z*dTau;

      // 近接重心
      const ids=this.grid.query(q.pos,P.eps); const neigh=[];
      for(const id of ids){
        if(id===q.id) continue;
        const other=this.particles.find(p=>p.id===id); if(!other||!other.alive) continue;
        const dx0=other.pos.x-q.pos.x, dy0=other.pos.y-q.pos.y, dz0=other.pos.z-q.pos.z;
        const d2=dx0*dx0+dy0*dy0+dz0*dz0; if(d2<=eps2) neigh.push({ref:other, d2});
      }
      neigh.sort((a,b)=>a.d2-b.d2); const take=Math.min(kNN,neigh.length);
      let px=0,pz=0; if(take>0){ for(let i=0;i<take;i++){ px+=neigh[i].ref.pos.x; pz+=neigh[i].ref.pos.z; } px/=take; pz/=take; px-=q.pos.x; pz-=q.pos.z; }
      const dxPeer=P.kappaP*px*dTau, dzPeer=P.kappaP*pz*dTau;

      // 合成
      q.pos.x += dxDiff + cx + dxPeer;
      q.pos.z += dzDiff + cz + dzPeer;
      q.pos.y = Math.max(0, y+dy);

      // 円錐側面で反射（外形のみ）
      const rad=this.radius(q.pos.y); const rr=Math.hypot(q.pos.x,q.pos.z);
      if(rr>rad){ const s=rad/rr; q.pos.x*=s; q.pos.z*=s; }

      // 成功
      if(q.pos.y>=P.ySucc){ q.alive=false; q.succT=this.t; this.succ++; }
    }

    // スポーン
    if(this.t - this.lastSpawn >= P.spawnInt){ this.spawn(P.batch,rng); this.lastSpawn=this.t; }
    this.t += dt;

    // TDCI(τ) を指数平滑
    const bins=16; const hist=new Array(bins).fill(0);
    const alivePts=act; for(const Pp of alivePts){ const ang=Math.atan2(Pp.z,Pp.x); let k=Math.floor(((ang+Math.PI)/(2*Math.PI))*bins); if(k===bins) k=bins-1; hist[k]++; }
    let s=0; const N=Math.max(1,alivePts.length); for(const h of hist){ const p=h/N; s+=p*p; }
    const lam=0.2; this.tdci = (1-lam)*this.tdci + lam*s;
  }
}

/***  DBSCAN（簡易）  ***/
class Clusterer{
  constructor(eps, minPts){ this.eps=eps; this.minPts=minPts; this.grid=new SpatialHash(eps); }
  detect(points){ // points: [{id,pos}]
    this.grid.clear();
    const visited=new Set(); const labels=new Map(); const pointsById=new Map(points.map(p=>[p.id,p]));
    for(const p of points){ this.grid.insert(p.id, p.pos); }
    const clusters=[]; const eps2=this.eps*this.eps;
    const neighOf=(p)=>{ const ids=this.grid.query(p.pos, this.eps); const arr=[]; for(const id of ids){ if(id===p.id) continue; const q=pointsById.get(id); if(!q) continue; const dx=q.pos.x-p.pos.x, dy=q.pos.y-p.pos.y, dz=q.pos.z-p.pos.z; const d2=dx*dx+dy*dy+dz*dz; if(d2<=eps2) arr.push(q); } return arr; };

    for(const p of points){
      if(visited.has(p.id)) continue;
      visited.add(p.id);
      const neigh=neighOf(p);
      if(neigh.length+1 < this.minPts){ labels.set(p.id,-1); continue; }
      const cluster=[]; clusters.push(cluster);
      cluster.push(p); labels.set(p.id, clusters.length-1);
      const seed=[...neigh];
      while(seed.length){
        const q=seed.pop();
        if(!visited.has(q.id)){
          visited.add(q.id);
          const neigh2=neighOf(q);
          if(neigh2.length+1>=this.minPts) seed.push(...neigh2);
        }
        if(!labels.has(q.id) || labels.get(q.id)===-1){
          labels.set(q.id, clusters.length-1); cluster.push(q);
        }
      }
    }
    return clusters.map(members=>{
      const c=new THREE.Vector3(); for(const m of members){ c.add(m.pos); } c.multiplyScalar(1/members.length);
      return {members, center:c};
    });
  }
}

/***  3Dレンダラ（InstancedMesh・円錐外形のみ）  ***/
class Renderer3D{
  constructor(canvas, H, R){
    this.canvas=canvas;
    this.scene=new THREE.Scene(); this.scene.background=new THREE.Color(0x0b1020);
    this.camera=new THREE.PerspectiveCamera(60, canvas.clientWidth/canvas.clientHeight, 0.1, 2000);
    this.camera.position.set(60,45,60); this.camera.lookAt(0,H/2,0);
    this.renderer=new THREE.WebGLRenderer({canvas, antialias:true});
    this.controls=new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.target.set(0,H/2,0);

    const amb=new THREE.AmbientLight(0xffffff,.7); this.scene.add(amb);
    const dir=new THREE.DirectionalLight(0xffffff,.9); dir.position.set(80,120,40); this.scene.add(dir);

    this.updateCone(H,R);

    const g=new THREE.SphereGeometry(0.35,16,16);
    const m=new THREE.MeshPhongMaterial({color:0x60a5fa, emissive:0x2563eb, emissiveIntensity:.18});
    this.capacity=8000;
    this.im=new THREE.InstancedMesh(g,m,this.capacity);
    this.im.count=0; this.scene.add(this.im);
    this.tmp=new THREE.Matrix4();

    window.addEventListener('resize',()=>this.resize());
    this.resize();
  }
  resize(){ const w=this.canvas.clientWidth, h=this.canvas.clientHeight; this.renderer.setSize(w,h,false); this.camera.aspect=w/Math.max(1,h); this.camera.updateProjectionMatrix(); }
  updateCone(H,R){
    if(this.cone){ this.scene.remove(this.cone); this.cone.geometry.dispose(); this.cone.material.dispose(); }
    const coneGeom=new THREE.CylinderGeometry(0,R,H, 48, 1, true); // open-ended, side-only
    const coneMat=new THREE.MeshPhongMaterial({color:0x4b5563, transparent:true, opacity:0.12, side:THREE.DoubleSide});
    this.cone=new THREE.Mesh(coneGeom, coneMat); this.cone.position.y=H/2; this.scene.add(this.cone);
  }
  updateParticles(positions){
    const n=Math.min(positions.length, this.capacity); this.im.count=n;
    for(let i=0;i<n;i++){ const p=positions[i]; this.tmp.makeTranslation(p.x,p.y,p.z); this.im.setMatrixAt(i,this.tmp); }
    this.im.instanceMatrix.needsUpdate=true;
  }
  render(){ this.controls.update(); this.renderer.render(this.scene,this.camera); }
}

/***  コントローラ  ***/
function readParams(){
  return {
    // env
    H:+UI('#H').value, R:+UI('#R').value, ySucc:+UI('#ySucc').value,
    vertexCap:+UI('#vertexCap').value, capRadius:+UI('#capRadius').value, gammaCong:+UI('#gammaCong').value,
    // TRT
    alpha0:+UI('#alpha0').value, alpha1:+UI('#alpha1').value, yStar:+UI('#yStar').value, tauS:+UI('#tauS').value, betaM:+UI('#betaM').value,
    // PRA
    uRate:+UI('#uRate').value, D0:+UI('#D0').value, kappaC:+UI('#kappaC').value, kappaP:+UI('#kappaP').value, rhoTau:+UI('#rhoTau').value,
    // population
    N0:+UI('#N0').value, batch:+UI('#batch').value, spawnInt:+UI('#spawnInt').value,
    // clustering
    eps:+UI('#eps').value, minPts:+UI('#minPts').value, detectInt:+UI('#detectInt').value
  };
}

let core=null, rng=null, view=null, clusterer=null;
let running=false, detectAcc=0;

function resetAll(){
  const p=readParams();
  core=new ABMCore(p);
  rng=mulberry32(+UI('#seed').value||12345);
  core.init(rng);
  clusterer=new Clusterer(p.eps, p.minPts);
  if(view){ view.updateCone(p.H,p.R); }
  updateStats(); draw(); toast('リセット完了 / Seed='+UI('#seed').value);
}

function updateStats(){
  UI('#stat_t').textContent=core.t.toFixed(2);
  UI('#stat_tau').textContent=core.tau.toFixed(2);
  UI('#stat_succ').textContent=core.succ;
  const rate= core.totalSpawned>0 ? (100*core.succ/core.totalSpawned):0;
  UI('#stat_rate').textContent=rate.toFixed(1)+'%';
  UI('#stat_active').textContent=core.particles.filter(p=>p.alive).length;
  UI('#stat_tdci').textContent=core.tdci.toFixed(3);
}

function draw(){
  if(!view) return;
  const pos=core.particles.filter(p=>p.alive).map(p=>p.pos);
  view.updateParticles(pos);
  view.render();
}

function runClusterDetection(){
  const pts=core.particles.filter(p=>p.alive).map(p=>({id:p.id, pos:p.pos}));
  if(pts.length===0){ UI('#stat_clusters').textContent='0'; UI('#stat_maxcl').textContent='0'; return; }
  const cs=clusterer.detect(pts); UI('#stat_clusters').textContent=cs.length; const mx=cs.reduce((a,c)=>Math.max(a,c.members.length),0); UI('#stat_maxcl').textContent=mx;
}

function loop(){
  if(!running){ requestAnimationFrame(loop); return; }
  const dt=+UI('#dt').value, T=+UI('#T').value;
  if(core.t>=T){ running=false; toast('終了 T に到達'); return; }
  core.step(dt, rng);
  detectAcc+=dt; if(detectAcc>=core.p.detectInt){ detectAcc=0; runClusterDetection(); }
  updateStats(); draw();
  requestAnimationFrame(loop);
}

/***  エクスポート類  ***/
function exportSnapshotCSV(){
  const rows=['t,tau,id,x,y,z,alive'];
  for(const p of core.particles){
    const {x,y,z}=p.pos; rows.push([core.t.toFixed(4), core.tau.toFixed(4), p.id, x.toFixed(4), y.toFixed(4), z.toFixed(4), p.alive?1:0].join(','));
  }
  download(rows.join('\n'),'abm_snapshot.csv','text/csv');
}
function exportSummaryCSV(){
  const rate = core.totalSpawned? core.succ/core.totalSpawned:0;
  const rows = [
    'metric,value',
    `t,${core.t.toFixed(4)}`,
    `tau,${core.tau.toFixed(4)}`,
    `success_count,${core.succ}`,
    `total_spawned,${core.totalSpawned}`,
    `success_rate,${rate.toFixed(6)}`,
    `tdci_tau,${core.tdci.toFixed(6)}`
  ];
  download(rows.join('\n'), 'abm_summary.csv','text/csv');
}
function exportConfig(){
  const cfg={ seed:+UI('#seed').value, dt:+UI('#dt').value, T:+UI('#T').value, params:readParams(), version:'ResearchReady v1.0', timestamp:new Date().toISOString() };
  download(JSON.stringify(cfg,null,2),'abm_config.json','application/json');
}

/***  ヘッドレスK試行（研究用）  ***/
async function headlessBatch(){
  const K=+UI('#trials').value; const dt=+UI('#dt').value, T=+UI('#T').value; const baseSeed=+UI('#seed').value||12345; const p=readParams();
  const results=[];
  for(let k=0;k<K;k++){
    const rngK=mulberry32(baseSeed + k*100003);
    const coreK=new ABMCore(p); coreK.init(rngK);
    const clK=new Clusterer(p.eps, p.minPts);
    let detAcc=0, maxCl=0;
    for(let t=0; t<T; t+=dt){
      coreK.step(dt, rngK);
      detAcc+=dt; if(detAcc>=p.detectInt){ detAcc=0; const pts=coreK.particles.filter(q=>q.alive).map(q=>({id:q.id,pos:q.pos})); const cs=clK.detect(pts); maxCl=Math.max(maxCl, cs.length); }
    }
    const rate = coreK.totalSpawned? coreK.succ/coreK.totalSpawned:0;
    results.push({succ:coreK.succ, total:coreK.totalSpawned, rate, tdci:coreK.tdci, maxCl});
  }
  const csv=['k,succ,total,rate,tdci,max_cluster'];
  results.forEach((r,i)=>csv.push([i+1,r.succ,r.total,r.rate.toFixed(6),r.tdci.toFixed(6),r.maxCl].join(',')));
  // 平均
  const mean=(arr,f)=>arr.reduce((s,x)=>s+f(x),0)/arr.length;
  csv.push(['mean',
    mean(results,r=>r.succ).toFixed(3),'',
    mean(results,r=>r.rate).toFixed(6),
    mean(results,r=>r.tdci).toFixed(6),
    mean(results,r=>r.maxCl).toFixed(3)
  ].join(','));
  download(csv.join('\n'),'headless_results.csv','text/csv');
  UI('#logBox').textContent = 'Headless K='+K+' 完了\n'+csv.slice(-5).join('\n');
}

/***  初期化  ***/
function main(){
  const canvas=UI('#canvas');
  const p=readParams();
  view=new Renderer3D(canvas, p.H, p.R);
  resetAll();

  UI('#btnStart').onclick=()=>{ if(!running){ running=true; requestAnimationFrame(loop); toast('開始'); } };
  UI('#btnPause').onclick=()=>{ running=false; toast('一時停止'); };
  UI('#btnReset').onclick=()=>{ running=false; resetAll(); };
  UI('#btnStep').onclick=()=>{ const dt=+UI('#dt').value; core.step(dt, rng); detectAcc+=dt; if(detectAcc>=core.p.detectInt){ detectAcc=0; runClusterDetection(); } updateStats(); draw(); };

  UI('#btnExportSnapshot').onclick=exportSnapshotCSV;
  UI('#btnExportSummary').onclick=exportSummaryCSV;
  UI('#btnExportConfig').onclick=exportConfig;
  UI('#btnHeadless').onclick=headlessBatch;

  // 主要パラメタ変更でリセット（可視化と物理条件の一貫性を担保）
  ['H','R','ySucc','vertexCap','capRadius','gammaCong','alpha0','alpha1','yStar','tauS','betaM','uRate','D0','kappaC','kappaP','rhoTau','N0','batch','spawnInt','eps','minPts','detectInt','seed'].forEach(id=>{
    UI('#'+id).addEventListener('change', ()=>{ running=false; resetAll(); });
  });
}

window.addEventListener('DOMContentLoaded', main);
</script>
</body>
</html>

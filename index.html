<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TRT・PRAシミュレータ ABM強化版 v6.0</title>
  <!-- Three.js r128 CDN (安定版) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root{
      --panel-bg:#ffffff;
      --panel-border:#e5e7eb;
      --panel-shadow:0 4px 20px rgba(0,0,0,0.12);
      --text:#1f2937;
      --subtext:#374151;
    }
    html,body{margin:0;padding:0;height:100%;font-family:Arial,Helvetica,sans-serif;background:#f0f2f5;color:var(--text)}
    #main-layout{display:flex;flex-direction:row;height:100vh;width:100vw;box-sizing:border-box;overflow:hidden}
    #canvas-container{flex:1 1 60vw;min-width:0;min-height:0;position:relative;background:#f8f8f8}
    #side-panels{flex:0 0 360px;display:flex;flex-direction:column;gap:12px;min-width:280px;max-width:100vw;box-sizing:border-box;overflow-y:auto;background:#f8fafb;border-left:1px solid var(--panel-border);padding:10px}
    .panel{background:var(--panel-bg);border-radius:12px;box-shadow:var(--panel-shadow);padding:16px}
    h1{font-size:18px;margin:0 0 10px;color:var(--text)}
    h2{font-size:14px;margin:14px 0 8px;border-bottom:1px solid var(--panel-border);padding-bottom:4px;color:var(--subtext)}
    .group{margin-bottom:10px;padding:10px;background:#f9fafb;border:1px solid var(--panel-border);border-radius:8px}
    .row{display:flex;align-items:center;gap:8px;margin:8px 0}
    .row label{flex:1;font-size:12px;color:#4b5563;font-weight:600}
    .row .val{min-width:48px;text-align:right;font-size:12px;color:#6b7280}
    input[type=range]{width:100%}
    input[type=text],input[type=number]{width:110px;padding:6px;border:1px solid var(--panel-border);border-radius:6px}
    button{padding:8px 10px;border:none;border-radius:6px;background:#3b82f6;color:#fff;cursor:pointer}
    button.secondary{background:#6b7280}
    button.ghost{background:#e5e7eb;color:#111827}
    button:disabled{opacity:0.6;cursor:not-allowed}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap}
    .stat-line{display:flex;justify-content:space-between;margin:6px 0;font-size:12px}
    .legend-item{display:flex;align-items:center;gap:8px;margin:6px 0;font-size:12px}
    .swatch{width:16px;height:16px;border-radius:50%}
    .swatch.square{border-radius:4px}
    .swatch.tri{clip-path:polygon(50% 0%,0% 100%,100% 100%)}

    /* ツールチップ */
    .tooltip{position:relative;display:inline-block;cursor:help}
    .tooltip .tip{
      visibility:hidden;opacity:0;transition:opacity .2s;
      position:absolute;z-index:1000;left:50%;transform:translateX(-50%);
      bottom:120%;width:260px;background:#111827;color:#fff;border-radius:8px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,0.25);font-size:12px;line-height:1.4
    }
    .tooltip:hover .tip{visibility:visible;opacity:1}

    /* レスポンシブ */
    @media (max-width:1024px){
      #main-layout{flex-direction:column;height:auto}
      #canvas-container{order:1;height:48vh;min-height:220px}
      #side-panels{order:2;flex-direction:column;overflow-y:visible}
    }
    @media (max-width:768px){
      #canvas-container{height:40vh}
      .btn-row{flex-direction:row;gap:6px}
    }
  </style>
</head>
<body>
  <div id="main-layout">
    <div id="canvas-container"></div>
    <div id="side-panels">
      <div class="panel" id="control-panel">
        <h1>TRT・PRA シミュレータ v6.0</h1>

        <div class="group">
          <h2>組織モデル 説明</h2>
          <div class="row" style="justify-content:space-between">
            <div>
              <span>中央集権型</span>
              <span class="tooltip">❓
                <span class="tip"><b>中央集権型</b>は意思決定が上層に集中し、統一性と効率性に優れる一方、現場の柔軟性や創発が抑制されやすい構造を指します。</span>
              </span>
            </div>
            <div>
              <span>分散自律型</span>
              <span class="tooltip">❓
                <span class="tip"><b>分散自律型</b>は権限が現場に分散し、適応性と革新が生まれやすい一方、全体調和の設計が課題になりやすい構造を指します。</span>
              </span>
            </div>
            <div>
              <span>ハイブリッド型</span>
              <span class="tooltip">❓
                <span class="tip"><b>ハイブリッド型</b>は中央の方針と現場裁量の両立を図り、効率と適応のバランスを狙う構造を指します。</span>
              </span>
            </div>
          </div>
        </div>

        <div class="group">
          <h2>シミュレーション制御</h2>
          <div class="btn-row">
            <button id="btn-start">開始</button>
            <button id="btn-pause" class="secondary">一時停止/再開</button>
            <button id="btn-reset" class="ghost">リセット</button>
          </div>
          <div class="row">
            <label>描画あり/なし（ヘッドレス）</label>
            <input type="checkbox" id="headlessToggle"/>
          </div>
          <div class="row">
            <label>乱数シード</label>
            <input type="number" id="seedInput" value="12345" />
          </div>
          <div class="row">
            <label>実時間倍率</label>
            <input type="range" id="timeScale" min="0.01" max="1" step="0.01" value="0.15"/>
            <span class="val" id="timeScaleVal">0.15</span>
          </div>
          <div class="row">
            <label>スポーン間隔[s]</label>
            <input type="range" id="spawnInterval" min="0.05" max="2" step="0.05" value="0.5"/>
            <span class="val" id="spawnIntervalVal">0.50</span>
          </div>
          <div class="row">
            <label>バッチサイズ</label>
            <input type="range" id="batchSize" min="1" max="20" step="1" value="4"/>
            <span class="val" id="batchSizeVal">4</span>
          </div>
        </div>

        <div class="group">
          <h2>資源タイプと初期配置</h2>
          <div class="row">
            <label>活用特化割合</label>
            <input type="range" id="exploiterRatio" min="0" max="1" step="0.05" value="0.30"/>
            <span class="val" id="exploiterRatioVal">0.30</span>
          </div>
          <div class="row">
            <label>探索特化割合</label>
            <input type="range" id="explorerRatio" min="0" max="1" step="0.05" value="0.30"/>
            <span class="val" id="explorerRatioVal">0.30</span>
          </div>
          <div class="row">
            <label>戦略的初期配置</label>
            <input type="checkbox" id="strategicSpawn" checked />
          </div>
          <div class="row">
            <label>資源異質性</label>
            <input type="range" id="heterogeneity" min="0" max="1" step="0.1" value="0.5"/>
            <span class="val" id="heterogeneityVal">0.5</span>
          </div>
          <div class="row">
            <label>寿命変動</label>
            <input type="range" id="lifespanVariance" min="0" max="1" step="0.1" value="0.3"/>
            <span class="val" id="lifespanVarianceVal">0.3</span>
          </div>
        </div>

        <div class="group">
          <h2>TRT / PRA 力</h2>
          <div class="row">
            <label>TRT強度</label>
            <input type="range" id="trtForce" min="0" max="0.08" step="0.001" value="0.018"/>
            <span class="val" id="trtForceVal">0.018</span>
          </div>
          <div class="row">
            <label>PRA強度</label>
            <input type="range" id="praForce" min="0" max="0.08" step="0.001" value="0.022"/>
            <span class="val" id="praForceVal">0.022</span>
          </div>
        </div>

        <div class="group">
          <h2>多重重力・環境</h2>
          <div class="row">
            <label>中央収束力</label>
            <input type="range" id="centralConv" min="0" max="0.15" step="0.001" value="0.03"/>
            <span class="val" id="centralConvVal">0.030</span>
          </div>
          <div class="row">
            <label>粒子引力</label>
            <input type="range" id="peerAttr" min="0" max="0.05" step="0.001" value="0.01"/>
            <span class="val" id="peerAttrVal">0.010</span>
          </div>
          <div class="row">
            <label>成功閾値(高さ)</label>
            <input type="range" id="successThreshold" min="20" max="50" step="1" value="38"/>
            <span class="val" id="successThresholdVal">38</span>
          </div>
          <div class="row">
            <label>減耗率(1/s)</label>
            <input type="range" id="attritionRate" min="0" max="0.1" step="0.001" value="0.02"/>
            <span class="val" id="attritionRateVal">0.020</span>
          </div>
        </div>

        <div class="group">
          <h2>比較分析（シナリオ）</h2>
          <div class="row">
            <label>シナリオ名</label>
            <input type="text" id="scenarioName" placeholder="例：分散自律・探索強め"/>
          </div>
          <div class="btn-row">
            <button id="btn-save-scn">保存</button>
            <button id="btn-load-scn" class="secondary">読込</button>
            <button id="btn-del-scn" class="ghost">削除</button>
          </div>
          <div class="row">
            <label>保存済み</label>
            <select id="scenarioList" style="flex:1"></select>
          </div>
        </div>

        <div class="group">
          <h2>複製実行（Monte Carlo）</h2>
          <div class="row">
            <label>複製回数</label>
            <input type="number" id="replications" min="1" max="500" value="20"/>
          </div>
          <div class="row">
            <label>最大シミュレート時間[s]</label>
            <input type="number" id="maxSimTime" min="5" max="600" value="60"/>
          </div>
          <div class="btn-row">
            <button id="btn-run-batch">複製実行（ヘッドレス）</button>
            <button id="btn-dl-csv" class="secondary" disabled>CSVダウンロード</button>
          </div>
        </div>
      </div>

      <div class="panel" id="stats-panel">
        <h2>統計</h2>
        <div class="stat-line"><span>経過時間</span><span id="stat-time">0.0 s</span></div>
        <div class="stat-line"><span>総発生</span><span id="stat-spawned">0</span></div>
        <div class="stat-line"><span>成功数</span><span id="stat-success">0</span></div>
        <div class="stat-line"><span>成功率</span><span id="stat-sr">0.0 %</span></div>
        <div class="stat-line"><span>アクティブ数</span><span id="stat-active">0</span></div>
        <div class="stat-line"><span>クラスター数</span><span id="stat-clusters">0</span></div>
      </div>

      <div class="panel" id="legend-panel">
        <h2>凡例</h2>
        <div class="legend-item"><span class="swatch" style="background:#3b82f6"></span><span>標準</span></div>
        <div class="legend-item"><span class="swatch square" style="background:#ef4444"></span><span>活用特化</span></div>
        <div class="legend-item"><span class="swatch tri" style="background:#10b981"></span><span>探索特化</span></div>
        <div class="legend-item"><span class="swatch" style="background:#00c853"></span><span>成功</span></div>
      </div>
    </div>
  </div>

  <script>
    // ========= 乱数（再現性確保のためのLCG） =========
    class LCG {
      constructor(seed=12345){ this.m=0x80000000; this.a=1103515245; this.c=12345; this.state=(seed>>>0)||12345; }
      next(){ this.state=(this.a*this.state+this.c)%this.m; return this.state/this.m; }
      range(min,max){ return min+(max-min)*this.next(); }
      pick(){ return this.next(); }
    }

    // ========= Three.js セットアップ =========
    const canvasContainer=document.getElementById('canvas-container');
    const scene=new THREE.Scene();
    scene.background=new THREE.Color(0xf8f8f8);
    const camera=new THREE.PerspectiveCamera(70, canvasContainer.clientWidth/Math.max(1,canvasContainer.clientHeight), 0.1, 1000);
    camera.position.set(48,42,58); camera.lookAt(0,18,0);
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
    renderer.shadowMap.enabled=true;
    canvasContainer.appendChild(renderer.domElement);

    const amb=new THREE.AmbientLight(0xffffff,0.75); scene.add(amb);
    const dir=new THREE.DirectionalLight(0xffffff,0.85); dir.position.set(50,100,50); dir.castShadow=true; scene.add(dir);

    // 地面
    const ground=new THREE.Mesh(new THREE.PlaneGeometry(240,240), new THREE.MeshPhongMaterial({color:0xe6e6e6, side:THREE.DoubleSide}));
    ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

    // 円錐（ワイヤーフレームで領域を可視化）
    const coneHeight=40, coneRadius=20;
    const coneGeo=new THREE.ConeGeometry(coneRadius, coneHeight, 48, 1, true);
    const coneMat=new THREE.MeshBasicMaterial({color:0x9e9e9e, wireframe:true, transparent:true, opacity:0.35});
    const cone=new THREE.Mesh(coneGeo, coneMat);
    cone.position.y=coneHeight/2;
    scene.add(cone);

    // リサイズ
    window.addEventListener('resize',()=>{
      const w=canvasContainer.clientWidth, h=Math.max(1,canvasContainer.clientHeight);
      camera.aspect=w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    });

    // ========= パラメータと状態 =========
    const params={
      timeScale:0.15, spawnInterval:0.5, batchSize:4,
      exploiterRatio:0.30, explorerRatio:0.30, strategicSpawn:true,
      heterogeneity:0.5, lifespanVariance:0.3,
      trtForce:0.018, praForce:0.022,
      centralConv:0.03, peerAttr:0.01,
      successThreshold:38, attritionRate:0.02,
    };

    let rng=new LCG(12345);
    let headless=false;
    let running=false, paused=false;
    let elapsed=0, lastSpawn=0, totalSpawned=0, successCount=0;
    let particles=[];
    let csvRows=null; // バッチ実行のCSVバッファ

    // ========= 粒子型 =========
    const Type={ STD:'std', EXP:'explore', EXPLOIT:'exploit' };

    class Particle {
      constructor(){
        this.type=this._decideType();
        this.pos=new THREE.Vector3(0,0.6,0);
        this.vel=new THREE.Vector3(rng.range(-0.02,0.02), rng.range(0.01,0.03), rng.range(-0.02,0.02));
        const v=(rng.pick()-0.5)*2*params.heterogeneity;
        this.trtAff=1 + (this.type===Type.EXPLOIT? +v : (this.type===Type.EXP? -v : 0));
        this.praAff=1 + (this.type===Type.EXP? +v : (this.type===Type.EXPLOIT? -v : 0));
        const baseLife=100; this.age=0; this.maxAge=baseLife*(1+(rng.pick()-0.5)*params.lifespanVariance);
        this.active=true; this.succeeded=false;
        this.mesh=this._buildMesh();
        scene.add(this.mesh);
      }
      _decideType(){
        const r=rng.pick();
        if(r < params.exploiterRatio) return Type.EXPLOIT;
        if(r < params.exploiterRatio+params.explorerRatio) return Type.EXP;
        return Type.STD;
      }
      _buildMesh(){
        let geo, col;
        if(this.type===Type.EXPLOIT){ geo=new THREE.BoxGeometry(0.8,0.8,0.8); col=0xef4444; }
        else if(this.type===Type.EXP){ geo=new THREE.ConeGeometry(0.5,1,14); col=0x10b981; }
        else { geo=new THREE.SphereGeometry(0.5,16,16); col=0x3b82f6; }
        const mat=new THREE.MeshPhongMaterial({color:col});
        const m=new THREE.Mesh(geo,mat); m.castShadow=true; m.position.copy(this.pos);
        return m;
      }
      _strategicSpawn(){
        // クラスター近傍 or 中央/周縁にバイアス
        if(this.type===Type.EXPLOIT){
          // 中央寄り
          const ang=rng.range(0,Math.PI*2);
          const r= rng.range(0, coneRadius*0.45);
          this.pos.x=Math.cos(ang)*r; this.pos.z=Math.sin(ang)*r;
        }else if(this.type===Type.EXP){
          // 周縁寄り
          const ang=rng.range(0,Math.PI*2);
          const r= rng.range(coneRadius*0.6, coneRadius*0.95);
          this.pos.x=Math.cos(ang)*r; this.pos.z=Math.sin(ang)*r;
        }else{
          const ang=rng.range(0,Math.PI*2);
          const r= rng.range(0, coneRadius*0.9);
          this.pos.x=Math.cos(ang)*r; this.pos.z=Math.sin(ang)*r;
        }
      }
      initPosition(){
        if(params.strategicSpawn) this._strategicSpawn();
        else{
          const ang=rng.range(0,Math.PI*2);
          const r=rng.range(0,coneRadius*0.9);
          this.pos.x=Math.cos(ang)*r; this.pos.z=Math.sin(ang)*r;
        }
        this.mesh.position.copy(this.pos);
      }
      update(dt){
        if(!this.active) return;
        // TRT（縦）: 下ほど強く上向き
        const hRatio=Math.max(0, Math.min(1, this.pos.y/coneHeight));
        this.vel.y += params.trtForce * (1 - hRatio) * this.trtAff * dt;

        // PRA（横）: ランダム方向、上ほど強い
        const jitterX=(rng.pick()-0.5)*2;
        const jitterZ=(rng.pick()-0.5)*2;
        const pra=params.praForce * (0.3 + 0.7*hRatio) * this.praAff;
        this.vel.x += pra * jitterX * dt;
        this.vel.z += pra * jitterZ * dt;

        // 中央収束（水平のみ）
        const toCenter=new THREE.Vector3(-this.pos.x, 0, -this.pos.z).normalize().multiplyScalar(params.centralConv*dt);
        this.vel.add(toCenter);

        // 粒子間引力（粗い近似：中心方向に弱くまとめる）
        if(params.peerAttr>0){
          this.vel.x += (-this.pos.x)*params.peerAttr*0.05*dt;
          this.vel.z += (-this.pos.z)*params.peerAttr*0.05*dt;
        }

        // 位置更新と減衰
        this.pos.addScaledVector(this.vel, dt*10);
        this.vel.multiplyScalar(0.985);

        // 円錐境界（半径線形縮小）
        const maxR=Math.max(0, coneRadius*(1 - this.pos.y/coneHeight));
        const rNow=Math.hypot(this.pos.x, this.pos.z);
        if(rNow>maxR){
          const s=maxR/(rNow||1e-6);
          this.pos.x*=s; this.pos.z*=s;
          this.vel.x*=0.6; this.vel.z*=0.6;
        }
        if(this.pos.y<0){ this.pos.y=0; this.vel.y=Math.abs(this.vel.y)*0.3; }

        // 成否・寿命
        this.age+=dt;
        if(this.pos.y>=params.successThreshold){
          this.active=false; this.succeeded=true; successCount++;
          this.mesh.material.color.set(0x00c853);
        }else if(this.age>this.maxAge || rng.pick()< (params.attritionRate*dt)){
          this.active=false; scene.remove(this.mesh);
        }else{
          // 色の明度を高さで変化
          this.mesh.position.copy(this.pos);
          this.mesh.material.color.offsetHSL(0,0,0); // no-op（維持）
        }
      }
    }

    function spawnBatch(n){
      for(let i=0;i<n;i++){
        const p=new Particle();
        p.initPosition();
        particles.push(p);
        totalSpawned++;
      }
    }

    // ========= UI束縛 =========
    function bindRange(id, key, fmt= (v)=>v.toFixed(3)){
      const el=document.getElementById(id);
      const lab=document.getElementById(id+'Val');
      const apply=()=>{
        const v=parseFloat(el.value);
        params[key]=v;
        if(lab) lab.textContent=(id==='timeScale'||id==='spawnInterval')? v.toFixed(2): fmt(v);
      };
      el.addEventListener('input', apply);
      apply();
    }
    bindRange('timeScale','timeScale',v=>v.toFixed(2));
    bindRange('spawnInterval','spawnInterval',v=>v.toFixed(2));
    bindRange('batchSize','batchSize',v=>v.toFixed(0));
    bindRange('exploiterRatio','exploiterRatio',v=>v.toFixed(2));
    bindRange('explorerRatio','explorerRatio',v=>v.toFixed(2));
    bindRange('heterogeneity','heterogeneity',v=>v.toFixed(1));
    bindRange('lifespanVariance','lifespanVariance',v=>v.toFixed(1));
    bindRange('trtForce','trtForce');
    bindRange('praForce','praForce');
    bindRange('centralConv','centralConv');
    bindRange('peerAttr','peerAttr');
    bindRange('successThreshold','successThreshold',v=>v.toFixed(0));
    bindRange('attritionRate','attritionRate');

    document.getElementById('strategicSpawn').addEventListener('change', e=>params.strategicSpawn=e.target.checked);
    document.getElementById('headlessToggle').addEventListener('change', e=>headless=e.target.checked);
    const seedInput=document.getElementById('seedInput');

    // ========= 統計表示 =========
    const statTime=document.getElementById('stat-time');
    const statSpawn=document.getElementById('stat-spawned');
    const statSucc=document.getElementById('stat-success');
    const statSR=document.getElementById('stat-sr');
    const statActive=document.getElementById('stat-active');
    const statClusters=document.getElementById('stat-clusters'); // 簡易：未実装→0

    function refreshStats(){
      statTime.textContent=elapsed.toFixed(1)+' s';
      statSpawn.textContent=String(totalSpawned);
      statSucc.textContent=String(successCount);
      statSR.textContent=(totalSpawned>0?(successCount/totalSpawned*100):0).toFixed(1)+' %';
      statActive.textContent=String(particles.filter(p=>p.active).length);
      statClusters.textContent='0';
    }

    // ========= ラン/ポーズ/リセット =========
    document.getElementById('btn-start').addEventListener('click', ()=>{
      if(!running){
        // 乱数初期化
        rng=new LCG(parseInt(seedInput.value||'12345',10));
        running=true; paused=false;
      }
    });
    document.getElementById('btn-pause').addEventListener('click', ()=>{ if(running) paused=!paused; });
    document.getElementById('btn-reset').addEventListener('click', resetSim);

    function resetSim(){
      particles.forEach(p=>{ if(p.mesh) scene.remove(p.mesh); });
      particles.length=0;
      elapsed=0; lastSpawn=0; totalSpawned=0; successCount=0;
      refreshStats();
    }

    // ========= シナリオ保存/読込 =========
    const scenarioNameEl=document.getElementById('scenarioName');
    const scenarioList=document.getElementById('scenarioList');
    function loadScenarioList(){
      scenarioList.innerHTML='';
      const keys=Object.keys(localStorage).filter(k=>k.startsWith('TRTPRA_SCN_')).sort();
      keys.forEach(k=>{
        const opt=document.createElement('option'); opt.value=k; opt.textContent=k.replace('TRTPRA_SCN_','');
        scenarioList.appendChild(opt);
      });
    }
    function currentConfig(){
      return JSON.stringify({
        params:{...params},
        headless, seed: parseInt(seedInput.value||'12345',10)
      });
    }
    function applyConfig(jsonStr){
      try{
        const obj=JSON.parse(jsonStr);
        Object.assign(params, obj.params||{});
        headless= !!obj.headless;
        seedInput.value= obj.seed??12345;
        // 反映
        for(const [id,key] of [
          ['timeScale','timeScale'],['spawnInterval','spawnInterval'],['batchSize','batchSize'],
          ['exploiterRatio','exploiterRatio'],['explorerRatio','explorerRatio'],['heterogeneity','heterogeneity'],
          ['lifespanVariance','lifespanVariance'],['trtForce','trtForce'],['praForce','praForce'],
          ['centralConv','centralConv'],['peerAttr','peerAttr'],['successThreshold','successThreshold'],
          ['attritionRate','attritionRate']
        ]){
          const el=document.getElementById(id);
          if(el){ el.value=params[key]; el.dispatchEvent(new Event('input')); }
        }
        document.getElementById('strategicSpawn').checked=params.strategicSpawn;
        document.getElementById('headlessToggle').checked=headless;
      }catch(e){ alert('シナリオ読み込みに失敗しました'); }
    }
    document.getElementById('btn-save-scn').addEventListener('click',()=>{
      const name=(scenarioNameEl.value||'scenario').trim();
      localStorage.setItem('TRTPRA_SCN_'+name, currentConfig());
      loadScenarioList();
    });
    document.getElementById('btn-load-scn').addEventListener('click',()=>{
      const key=scenarioList.value; if(!key){ alert('シナリオを選択してください'); return; }
      const data=localStorage.getItem(key); if(!data){ alert('データが見つかりません'); return; }
      applyConfig(data);
    });
    document.getElementById('btn-del-scn').addEventListener('click',()=>{
      const key=scenarioList.value; if(!key){ alert('シナリオを選択してください'); return; }
      localStorage.removeItem(key); loadScenarioList();
    });
    loadScenarioList();

    // ========= バッチ（複製）実行 =========
    const btnRunBatch=document.getElementById('btn-run-batch');
    const btnDlCsv=document.getElementById('btn-dl-csv');
    btnRunBatch.addEventListener('click', async ()=>{
      const reps=parseInt(document.getElementById('replications').value||'10',10);
      const maxT=parseFloat(document.getElementById('maxSimTime').value||'60');
      csvRows=[['rep','seed','time','spawned','success','successRate(%)']];
      btnRunBatch.disabled=true; btnDlCsv.disabled=true;

      for(let r=0;r<reps;r++){
        const seedBase=parseInt(seedInput.value||'12345',10);
        const thisSeed= (seedBase + r*9973)>>>0;
        // ヘッドレスで1本実行
        const res= await runOneHeadless(thisSeed, maxT);
        csvRows.push([
          r+1, thisSeed, res.time.toFixed(2), res.spawned, res.success, (res.spawned>0?(res.success/res.spawned*100):0).toFixed(2)
        ]);
      }
      btnRunBatch.disabled=false; btnDlCsv.disabled=false;
    });
    btnDlCsv.addEventListener('click', ()=>{
      if(!csvRows){ return; }
      const csv=csvRows.map(row=>row.join(',')).join('\n');
      const blob=new Blob([csv],{type:'text/csv'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url; a.download='trt_pra_batch.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    async function runOneHeadless(seed, maxT){
      // 現在のUI設定を使用しつつ、描画なしで高速実行
      const backup={
        running, paused, headless, rng, elapsed, lastSpawn, totalSpawned, successCount, particles
      };
      running=false; paused=false; headless=true;
      rng=new LCG(seed);
      elapsed=0; lastSpawn=0; totalSpawned=0; successCount=0;
      particles=[];

      const dtBase=0.016;
      while(elapsed<maxT){
        // スポーン
        if((elapsed - lastSpawn) > params.spawnInterval){
          spawnBatch(params.batchSize);
          lastSpawn=elapsed;
        }
        // 更新
        const dt= dtBase*params.timeScale;
        for(let i=0;i<particles.length;i++) particles[i].update(dt);
        particles=particles.filter(p=>p.active);
        elapsed+=dt;
      }
      // 後始末：可視Meshは削除（ヘッドレス時は生成されないが保険）
      particles.forEach(p=>{ if(p.mesh) scene.remove(p.mesh); });
      const res={time:elapsed, spawned:totalSpawned, success:successCount};
      // 復元
      ({running, paused, headless, rng, elapsed, lastSpawn, totalSpawned, successCount, particles}=backup);
      return res;
    }

    // ========= ループ =========
    let last=performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dtReal=(now-last)*0.001; last=now;
      if(!running || paused) { if(!headless) renderer.render(scene,camera); return; }

      const dt= dtReal*params.timeScale;

      // スポーン
      if((elapsed - lastSpawn) > params.spawnInterval){
        spawnBatch(params.batchSize);
        lastSpawn=elapsed;
      }
      // 更新
      for(let i=0;i<particles.length;i++) particles[i].update(dt);
      particles=particles.filter(p=>p.active);
      elapsed+=dt;

      refreshStats();
      if(!headless) renderer.render(scene,camera);
    }
    requestAnimationFrame(loop);

    // 初期状態の可視更新
    refreshStats();

    // 注記：花火などのエフェクトは一切実装していません（描画負荷と可搬性のため完全に削除）。
  </script>
</body>
</html>

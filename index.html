<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TRT・PRA シミュレータ v5.5（最終版）</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
body { margin:0; font-family: Arial, sans-serif; background:#f0f0f0; overflow:hidden; }
#canvas-container { position:relative; width:100vw; height:100vh; cursor: move; }
.panel { position:absolute; background:rgba(255,255,255,0.98); padding:20px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; max-height:90vh; overflow-y:auto; }
#control-panel { bottom:20px; left:20px; width:380px; }
#stats-panel { top:20px; right:20px; width:320px; font-size:13px; color:#1f2937; }
h1, h2 { margin-top:0; color:#1f2937; }
h1 { font-size:20px; display: flex; justify-content: space-between; align-items: center; }
h2 { font-size:16px; border-bottom:1px solid #e5e7eb; padding-bottom:8px; margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;}
.parameter-group { margin-bottom:15px; padding-top: 10px; }
.parameter-group:first-child { padding-top: 0; }
.parameter { margin-bottom:10px; }
.parameter label { display:block; font-size:12px; color:#4b5563; margin-bottom:4px; font-weight:600; cursor: help; }
input[type=range], input[type=number], select { width:100%; box-sizing: border-box; }
input:disabled, select:disabled, button:disabled { opacity: 0.5; cursor: not-allowed; }
.parameter-value { font-size:11px; color:#6b7280; margin-left:8px; float:right; }
.button-group { display:flex; gap:8px; flex-wrap:wrap; margin-top:15px; }
button.btn { flex-grow:1; padding:8px 12px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer; font-size:13px; transition:background 0.2s; }
button.btn:hover:not(:disabled) { background:#2563eb; }
button.btn-secondary { background:#6b7280; }
button.btn-secondary:hover:not(:disabled) { background:#4b5563; }
#toggle-control-panel { font-size: 14px; background: none; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px 8px; font-weight: bold; }
h2 input[type=checkbox] { margin-left: 10px; transform: scale(1.2); cursor: pointer;}
.legend { position:absolute; top:20px; left:20px; background:rgba(255,255,255,0.98); padding:15px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; font-size:12px; color:#1f2937; }
.legend-item { display:flex; align-items:center; margin-bottom:5px; }
.legend-color { width:15px; height:15px; margin-right:8px; border-radius:3px; }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="legend-panel" class="legend">
  <h2>資源の発展段階</h2>
  <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div>純粋探索</div>
  <div class="legend-item"><div class="legend-color" style="background:#0000FF"></div>移行期</div>
  <div class="legend-item"><div class="legend-color" style="background:#FFFF00"></div>応用開発</div>
  <div class="legend-item"><div class="legend-color" style="background:#FF0000"></div>市場活用</div>
</div>
<div id="stats-panel" class="panel">
  <h2>リアルタイム指標</h2>
  <div>シミュレーション時間: <span id="sim-time">0.0</span> 年</div>
  <div>市場化成功数: <span id="success-count">0</span></div>
  <div>成功率: <span id="success-rate">0.0%</span></div>
  <div>活性資源数: <span id="active-particles">0</span></div>
  <div>累計投入資源: <span id="total-spawned">0</span></div>
  <div>再利用資源数: <span id="recycled-count">0</span></div>
</div>
<div id="control-panel" class="panel">
  <h1>TRT・PRA シミュレータ v5.5<button id="toggle-control-panel">[-]</button></h1>
  <div class="content-wrapper">
    <div class="parameter-group">
      <h2>シミュレーション制御</h2>
      <div class="parameter">
        <label for="timeScale">時間スケール <span class="parameter-value" id="timeScale-value">0.1</span></label>
        <input type="range" id="timeScale" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateParameters()">
      </div>
       <div class="parameter">
        <label for="initialParticles">初期資源数 <span class="parameter-value" id="initialParticles-value">20</span></label>
        <input type="range" id="initialParticles" min="1" max="100" value="20" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="spawnInterval">資源投入間隔 (年) <span class="parameter-value" id="spawnInterval-value">0.5</span></label>
        <input type="range" id="spawnInterval" min="0.1" max="2.0" value="0.5" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="batchSize">投入バッチサイズ <span class="parameter-value" id="batchSize-value">3</span></label>
        <input type="range" id="batchSize" min="1" max="10" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>TRT (垂直推進) パラメータ</h2>
      <div class="parameter">
        <label for="trtForce" title="資源を円錐の上方向（市場化方向）へ押し上げる基本的な力。">垂直推進力 <span class="parameter-value" id="trtForce-value">0.015</span></label>
        <input type="range" id="trtForce" min="0" max="0.05" value="0.015" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="trtAcceleration" title="ティッピングポイントを超えた資源の上昇を加速させる度合い。">上昇加速度 <span class="parameter-value" id="trtAcceleration-value">1.0</span></label>
        <input type="range" id="trtAcceleration" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="tippingPoint" title="上昇加速度が働き始める円錐の高さの閾値。">ティッピングポイント <span class="parameter-value" id="tippingPoint-value">0.7</span></label>
        <input type="range" id="tippingPoint" min="0.5" max="0.9" value="0.7" step="0.05" oninput="updateParameters()">
      </div>
    </div>
     <div class="parameter-group">
      <h2>PRA (水平拡散) パラメータ</h2>
      <div class="parameter">
        <label for="praForce" title="資源が水平方向にランダムに移動する力。探索範囲の拡大に寄与。">水平拡散力 <span class="parameter-value" id="praForce-value">0.02</span></label>
        <input type="range" id="praForce" min="0" max="0.05" value="0.02" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="praDiversity" title="水平方向への拡散の多様性を維持する係数。">多様性維持係数 <span class="parameter-value" id="praDiversity-value">1.0</span></label>
        <input type="range" id="praDiversity" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>多重重力源パラメータ <input type="checkbox" id="multiGravityEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="peerAttraction" title="資源同士が互いに引き合う力。知識の共有や協業を模倣し、クラスター形成を促す。">粒子間引力 <span class="parameter-value" id="peerAttraction-value">0.01</span></label>
        <input type="range" id="peerAttraction" min="0" max="0.05" value="0.01" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="attractionRange" title="粒子間引力が働く最大の距離。">引力作用範囲 <span class="parameter-value" id="attractionRange-value">5</span></label>
        <input type="range" id="attractionRange" min="2" max="10" value="5" step="1" oninput="updateParameters()">
      </div>
       <div class="parameter">
        <label for="centralConvergence" title="資源が円錐の中心に向かう力。開発の方向性を中央に集約させる。">中央収束力 <span class="parameter-value" id="centralConvergence-value">0.03</span></label>
        <input type="range" id="centralConvergence" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="marketPull" title="資源が円錐の頂点（市場化）に引き寄せられる力。市場の魅力を示す。">市場引力 <span class="parameter-value" id="marketPull-value">0.02</span></label>
        <input type="range" id="marketPull" min="0" max="0.05" value="0.02" step="0.005" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>環境・再利用パラメータ <input type="checkbox" id="envBiasEnabled" checked onchange="updateParameters()"></h2>
       <div class="parameter">
        <label for="recyclingRate" title="失敗した資源が円錐の底から再投入される確率。">資源の再利用率 <span class="parameter-value" id="recyclingRate-value">0.1</span></label>
        <input type="range" id="recyclingRate" min="0" max="1" value="0.1" step="0.05" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="vertexCapacity" title="円錐の頂点付近（市場）が一度に受け入れられる資源の最大数。">頂点最大容量 <span class="parameter-value" id="vertexCapacity-value">5</span></label>
        <input type="range" id="vertexCapacity" min="1" max="15" value="5" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="button-group">
      <button class="btn" onclick="startSimulation()">開始</button>
      <button class="btn btn-secondary" onclick="pauseSimulation()">一時停止</button>
      <button class="btn btn-secondary" onclick="resetSimulation()">リセット</button>
    </div>
  </div>
</div>

<script>
let scene, camera, renderer, coneGroup, controls;
let particles = [], effectParticles = [], nextParticleId = 0;
let animationId;
let simulationState = {
  isRunning: false, isPaused: false, elapsedTime: 0, lastSpawnTime: 0,
  totalSpawned: 0, successCount: 0, recycledCount: 0, log: []
};
const coneHeight = 40, coneRadius = 20;
let parameters = {};

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(40, 40, 40);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, coneHeight/2, 0);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  const gridHelper = new THREE.GridHelper(coneRadius * 2, 20, 0x888888, 0xcccccc);
  gridHelper.position.y = 0.01;
  gridHelper.material.opacity = 0.2;
  gridHelper.material.transparent = true;
  scene.add(gridHelper);

  coneGroup = new THREE.Group();
  scene.add(coneGroup);
  
  const coneSegments = 4, segmentHeight = coneHeight / coneSegments;
  const colors = [0x8b5cf6, 0x0000FF, 0xFFFF00, 0xFF0000]; 
  
  for (let i = 0; i < coneSegments + 1; i++) {
      const y = i * segmentHeight;
      const radius = coneRadius * (1 - y / coneHeight);
      
      if (radius > 0) {
        const ringGeom = new THREE.RingGeometry(radius - 0.1, radius, 64);
        const ringMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.position.y = y;
        ring.rotation.x = -Math.PI/2;
        coneGroup.add(ring);
      }
  }

  window.addEventListener('resize', onWindowResize);
  setupUIListeners();
  updateParameters();
  resetSimulation();
  animate();
}

class Particle {
  constructor(id, position, isRecycled = false) {
    this.id = id;
    this.position = position.clone();
    this.velocity = new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
    this.isActive = true;
    this.isFading = false;
    this.fadingTime = 0;

    const geometry = new THREE.SphereGeometry(0.3, 16, 16);
    const material = new THREE.MeshPhongMaterial({color: this.getColor(), transparent: true});
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.copy(this.position);
    scene.add(this.mesh);
    if (isRecycled) {
        this.mesh.scale.set(0.1, 0.1, 0.1);
    }
  }
  
  update(deltaTime, allParticles) {
    if (this.isFading) {
        this.fadingTime += deltaTime;
        const duration = 0.4;
        if (this.fadingTime >= duration) {
            this.isFading = false;
            if(this.mesh.parent) scene.remove(this.mesh);
        }
        return;
    }
    if (!this.isActive) return;

    this.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);

    const hRatio = this.position.y / coneHeight;

    this.velocity.y += parameters.trtForce * (1-hRatio) * (hRatio < parameters.tippingPoint ? 1 : parameters.trtAcceleration) * deltaTime;
    this.velocity.x += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;
    this.velocity.z += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;

    if (parameters.multiGravityEnabled) {
        this.velocity.add(new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize().multiplyScalar(parameters.centralConvergence * hRatio * deltaTime));
        if(hRatio > 0.7) this.velocity.add(new THREE.Vector3(0, parameters.successThreshold - this.position.y, 0).normalize().multiplyScalar(parameters.marketPull * deltaTime));
        
        let attraction = new THREE.Vector3();
        allParticles.forEach(p => {
            if (p.id !== this.id && p.isActive) {
                const dist = this.position.distanceTo(p.position);
                if (dist < parameters.attractionRange && dist > 0.1) {
                    const force = p.position.clone().sub(this.position).normalize().multiplyScalar(1 / (dist*dist));
                    attraction.add(force);
                }
            }
        });
        this.velocity.add(attraction.multiplyScalar(parameters.peerAttraction * deltaTime));
    }
    
    if (parameters.envBiasEnabled && this.position.y > (coneHeight - 5)) {
        let congestion = allParticles.filter(p => p.id !== this.id && p.isActive && this.position.distanceTo(p.position) < 2).length;
        if (congestion >= parameters.vertexCapacity) this.velocity.y *= 0.8;
    }
    
    this.position.add(this.velocity.clone().multiplyScalar(deltaTime * parameters.timeScale * 10));
    
    const maxRadius = coneRadius * (1 - this.position.y/coneHeight);
    if (Math.sqrt(this.position.x**2 + this.position.z**2) > maxRadius || this.position.y < 0) {
        if (parameters.envBiasEnabled && Math.random() < parameters.recyclingRate) {
            this.recycle();
        } else {
            this.fail();
        }
        return;
    }
    
    if (this.position.y >= parameters.successThreshold) {
        this.succeed();
        return;
    }
    
    this.mesh.position.copy(this.position);
    this.mesh.material.color.set(this.getColor());
  }

  getColor() {
    const h = this.position.y/coneHeight;
    if (h<0.25) return 0x8b5cf6;
    if (h<0.5) return 0x0000FF;
    if (h<0.75) return 0xFFFF00;
    return 0xFF0000;
  }

  succeed() {
    if(!this.isActive) return;
    this.isActive = false;
    simulationState.successCount++;
    this.fadeOut();
  }

  fail() {
    if(!this.isActive) return;
    this.isActive = false;
    this.fadeOut();
  }
  
  recycle() {
    simulationState.recycledCount++;
    const angle = Math.random()*Math.PI*2;
    const radius = Math.random()*coneRadius*0.9;
    this.position.set(Math.cos(angle)*radius, 1, Math.sin(angle)*radius);
    this.velocity.set((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
    this.mesh.scale.set(0.1, 0.1, 0.1);
  }

  fadeOut() {
    this.isFading = true;
    if(this.mesh) createBubblePopEffect(this.mesh.position, this.mesh.material.color);
  }
}

function createBubblePopEffect(position, color) {
    const popCount = 5;
    for (let i=0; i < popCount; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 4, 4);
        const material = new THREE.MeshBasicMaterial({color: color, transparent: true});
        const p = new THREE.Mesh(geometry, material);
        p.position.copy(position);
        p.velocity = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(Math.random() * 3);
        p.lifespan = Math.random() * 0.5 + 0.2;
        p.age = 0;
        effectParticles.push(p);
        scene.add(p);
    }
}

function createInitialParticles() {
  particles.forEach(p => scene.remove(p.mesh));
  particles = [];
  nextParticleId = 0;
  const count = parameters.initialParticles;
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2; const radius = Math.random()*coneRadius*0.9;
    particles.push(new Particle(nextParticleId++, new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius)));
  }
  simulationState.totalSpawned += count;
}

function startSimulation() {
  if(simulationState.isRunning && !simulationState.isPaused) return;
  if(!simulationState.isRunning) resetSimulation();
  simulationState.isRunning = true;
  simulationState.isPaused = false;
}

function pauseSimulation() { if(simulationState.isRunning) simulationState.isPaused = !simulationState.isPaused; }

function resetSimulation() {
  simulationState.isRunning = false;
  simulationState.isPaused = false;
  simulationState.elapsedTime = 0;
  simulationState.lastSpawnTime = 0;
  simulationState.totalSpawned = 0;
  simulationState.successCount = 0;
  simulationState.recycledCount = 0;
  createInitialParticles();
  updateStats();
}

const clock = new THREE.Clock();
function animate() {
  animationId = requestAnimationFrame(animate);
  controls.update();
  
  const deltaTime = clock.getDelta();

  if (simulationState.isRunning && !simulationState.isPaused) {
    simulationState.elapsedTime += deltaTime * parameters.timeScale;
    
    if (simulationState.elapsedTime - simulationState.lastSpawnTime >= parameters.spawnInterval) {
      for(let i=0;i<parameters.batchSize;i++){
        const angle = Math.random()*Math.PI*2, radius = Math.random()*coneRadius*0.9;
        particles.push(new Particle(nextParticleId++, new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius)));
      }
      simulationState.totalSpawned += parameters.batchSize;
      simulationState.lastSpawnTime = simulationState.elapsedTime;
    }
    
    particles.forEach(p => p.update(deltaTime, particles));
    particles = particles.filter(p => p.isActive || p.isFading);
    updateStats();
  }

  effectParticles.forEach((p, index) => {
    p.age += deltaTime;
    if (p.age > p.lifespan) {
        scene.remove(p);
        effectParticles.splice(index, 1);
    } else {
        p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
        p.material.opacity = 1.0 - (p.age / p.lifespan);
    }
  });
  
  renderer.render(scene, camera);
}

function updateParameters() {
  document.querySelectorAll('#control-panel input, #control-panel select').forEach(el => {
    let value;
    if (el.type === 'checkbox') value = el.checked;
    else if (el.type === 'range' || el.type === 'number') value = parseFloat(el.value);
    else value = el.value;
    parameters[el.id] = value;
    const valEl = document.getElementById(el.id+'-value');
    if(valEl) valEl.textContent = value;
  });
  parameters.successThreshold = coneHeight - 2;

  ['multiGravityEnabled', 'envBiasEnabled'].forEach(groupId => {
    const group = document.querySelector(`#${groupId}`).closest('.parameter-group');
    const isEnabled = parameters[groupId];
    group.querySelectorAll('input[type=range], input[type=number], select').forEach(input => {
      if(input.id !== groupId) input.disabled = !isEnabled;
    });
  });
}

function updateStats() {
  document.getElementById('sim-time').textContent = simulationState.elapsedTime.toFixed(1);
  document.getElementById('success-count').textContent = simulationState.successCount;
  document.getElementById('active-particles').textContent = particles.filter(p=>p.isActive).length;
  document.getElementById('total-spawned').textContent = simulationState.totalSpawned;
  const rate = simulationState.totalSpawned>0 ? (simulationState.successCount/simulationState.totalSpawned)*100 : 0;
  document.getElementById('success-rate').textContent = rate.toFixed(1)+'%';
  document.getElementById('recycled-count').textContent = simulationState.recycledCount;
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function setupUIListeners() {
    document.querySelectorAll('#control-panel input, #control-panel select').forEach(el => el.addEventListener('input', updateParameters));
    document.getElementById('toggle-control-panel').addEventListener('click', () => {
        const content = document.querySelector('#control-panel .content-wrapper');
        const button = document.getElementById('toggle-control-panel');
        content.style.display = content.style.display === 'none' ? '' : 'none';
        button.textContent = content.style.display === 'none' ? '[+]' : '[-]';
    });
}
init();
</script>
</body>
</html>

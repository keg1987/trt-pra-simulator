<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TRT・PRA シミュレータ v5.5</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
body { margin:0; font-family: Arial,sans-serif; background:#f0f0f0; overflow:hidden; }
#canvas-container { position:relative; width:100vw; height:100vh; }
.panel { position:absolute; background:rgba(255,255,255,0.98); padding:20px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; max-height:90vh; overflow-y:auto; }
#control-panel { bottom:20px; left:20px; width:400px; }
#stats-panel { top:20px; right:20px; width:320px; font-size:13px; color:#1f2937; }
h1,h2 { margin-top:0; color:#1f2937; }
h1 { font-size:20px; display: flex; justify-content: space-between; align-items: center; }
h2 { font-size:16px; border-bottom:1px solid #e5e7eb; padding-bottom:8px; margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;}
.parameter-group { margin-bottom:18px; }
.parameter { margin-bottom:10px; }
.parameter label { display:block; font-size:12px; color:#4b5563; margin-bottom:4px; font-weight:600; cursor: help; }
input[type=range], select { width:100%; }
input:disabled { opacity: 0.5; }
.parameter-value { font-size:11px; color:#6b7280; margin-left:8px; float:right; }
.button-group { display:flex; gap:8px; flex-wrap:wrap; margin-top:15px; }
button.btn { flex-grow:1; padding:8px 12px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer; font-size:13px; transition:background 0.2s; }
button.btn:hover { background:#2563eb; }
button.btn-secondary { background:#6b7280; }
button.btn-secondary:hover { background:#4b5563; }
#toggle-control-panel { font-size: 14px; background: none; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px 8px; font-weight: bold; }
h2 input[type=checkbox] { margin-left: 10px; transform: scale(1.2); cursor: pointer;}
.legend { position:absolute; top:20px; left:20px; background:rgba(255,255,255,0.98); padding:15px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; font-size:12px; color:#1f2937; }
.legend-item { display:flex; align-items:center; margin-bottom:5px; }
.legend-color { width:15px; height:15px; margin-right:8px; border-radius:3px; }
hr.split { border: none; border-top: 1.5px dashed #bbb; margin: 22px 0 10px 0; }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="legend-panel" class="legend">
  <h2>資源の発展段階</h2>
  <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div>純粋探索</div>
  <div class="legend-item"><div class="legend-color" style="background:#0000FF"></div>移行期</div>
  <div class="legend-item"><div class="legend-color" style="background:#FFFF00"></div>応用開発</div>
  <div class="legend-item"><div class="legend-color" style="background:#FF0000"></div>市場活用</div>
</div>
<div id="stats-panel" class="panel">
  <h2>リアルタイム指標</h2>
  <div>シミュレーション時間: <span id="sim-time">0.0</span> 年</div>
  <div>市場化成功数: <span id="success-count">0</span></div>
  <div>成功率: <span id="success-rate">0.0%</span></div>
  <div>活性資源数: <span id="active-particles">0</span></div>
  <div>累計投入資源: <span id="total-spawned">0</span></div>
</div>
<div id="control-panel" class="panel">
  <h1>TRT・PRA シミュレータ v5.5<button id="toggle-control-panel">[-]</button></h1>
  <div class="content-wrapper">
    <div class="parameter-group">
      <h2>戦略的初期配置</h2>
      <div class="parameter">
        <label for="initialPlacementStrategy">初期配置戦略</label>
        <select id="initialPlacementStrategy" onchange="updateParameters()">
          <option value="random">ランダム</option>
          <option value="focused">集中型</option>
          <option value="diversified">分散型</option>
          <option value="clustered">クラスター型</option>
          <option value="edge">エッジ探索型</option>
        </select>
      </div>
      <div class="parameter">
        <label for="initialParticles">初期資源数 <span class="parameter-value" id="initialParticles-value">20</span></label>
        <input type="range" id="initialParticles" min="1" max="100" value="20" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>シミュレーション制御</h2>
      <div class="parameter">
        <label for="timeScale">時間スケール <span class="parameter-value" id="timeScale-value">0.1</span></label>
        <input type="range" id="timeScale" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="spawnInterval">資源投入間隔 (年) <span class="parameter-value" id="spawnInterval-value">0.5</span></label>
        <input type="range" id="spawnInterval" min="0.1" max="2.0" value="0.5" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="batchSize">投入バッチサイズ <span class="parameter-value" id="batchSize-value">3</span></label>
        <input type="range" id="batchSize" min="1" max="10" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    <hr class="split">
    <div class="parameter-group">
      <h2>TRTパラメータ</h2>
      <div class="parameter">
        <label for="trtForce" title="資源を円錐の上方向（市場化方向）へ押し上げる基本的な力。">垂直推進力 (TRT) <span class="parameter-value" id="trtForce-value">0.015</span></label>
        <input type="range" id="trtForce" min="0" max="0.05" value="0.015" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="trtAcceleration" title="ティッピングポイントを超えた資源の上昇を加速させる度合い。">上昇加速度 (TRT) <span class="parameter-value" id="trtAcceleration-value">1.0</span></label>
        <input type="range" id="trtAcceleration" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="tippingPoint" title="上昇加速度が働き始める円錐の高さの閾値。">ティッピングポイント (TRT) <span class="parameter-value" id="tippingPoint-value">0.7</span></label>
        <input type="range" id="tippingPoint" min="0.5" max="0.9" value="0.7" step="0.05" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="reuseRate" title="消失した資源が再利用される確率（0=再利用なし, 1=必ず再利用）">資源再利用率 (TRT) <span class="parameter-value" id="reuseRate-value">0.2</span></label>
        <input type="range" id="reuseRate" min="0" max="1" value="0.2" step="0.05" oninput="updateParameters()">
      </div>
    </div>
    <hr class="split">
    <div class="parameter-group">
      <h2>PRAパラメータ</h2>
      <div class="parameter">
        <label for="praForce" title="資源が水平方向にランダムに移動する力。探索範囲の拡大に寄与。">水平拡散力 (PRA) <span class="parameter-value" id="praForce-value">0.02</span></label>
        <input type="range" id="praForce" min="0" max="0.05" value="0.02" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="praDiversity" title="水平方向への拡散の多様性を維持する係数。">多様性維持係数 (PRA) <span class="parameter-value" id="praDiversity-value">1.0</span></label>
        <input type="range" id="praDiversity" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>
    <hr class="split">
    <div class="parameter-group">
      <h2>多重重力源パラメータ <input type="checkbox" id="multiGravityEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="centralConvergence" title="資源が円錐の中心に向かう力。開発の方向性を中央に集約させる。">中央収束力 <span class="parameter-value" id="centralConvergence-value">0.03</span></label>
        <input type="range" id="centralConvergence" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterConvergence" title="形成されたクラスター（技術群）の中心に資源が集まる力。">クラスター内収束力 <span class="parameter-value" id="clusterConvergence-value">0.04</span></label>
        <input type="range" id="clusterConvergence" min="0" max="0.1" value="0.04" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterInertia" title="クラスターがその動きを維持しようとする力。技術群の安定性を示す。">クラスター慣性 <span class="parameter-value" id="clusterInertia-value">0.015</span></label>
        <input type="range" id="clusterInertia" min="0" max="0.05" value="0.015" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="marketPull" title="資源が円錐の頂点（市場化）に引き寄せられる力。市場の魅力を示す。">市場引力 <span class="parameter-value" id="marketPull-value">0.02</span></label>
        <input type="range" id="marketPull" min="0" max="0.05" value="0.02" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="peerAttraction" title="資源同士が互いに引き合う力。知識の共有や協業を模倣する。">粒子間引力 <span class="parameter-value" id="peerAttraction-value">0.01</span></label>
        <input type="range" id="peerAttraction" min="0" max="0.05" value="0.01" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="attractionRange" title="粒子間引力が働く最大の距離。">引力作用範囲 <span class="parameter-value" id="attractionRange-value">5</span></label>
        <input type="range" id="attractionRange" min="2" max="10" value="5" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterThreshold" title="クラスターと見なされるために必要な近接資源の最小数。">クラスター形成閾値 <span class="parameter-value" id="clusterThreshold-value">3</span></label>
        <input type="range" id="clusterThreshold" min="2" max="8" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    <hr class="split">
    <div class="parameter-group">
      <h2>環境バイアス・頂点容量制限 <input type="checkbox" id="envBiasEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="coneTiltX" title="円錐全体をX軸周りに傾ける。特定分野への技術開発の偏りをシミュレート。">円錐傾斜X軸 <span class="parameter-value" id="coneTiltX-value">0</span></label>
        <input type="range" id="coneTiltX" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="coneTiltZ" title="円錐全体をZ軸周りに傾ける。特定分野への技術開発の偏りをシミュレート。">円錐傾斜Z軸 <span class="parameter-value" id="coneTiltZ-value">0</span></label>
        <input type="range" id="coneTiltZ" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="vertexCapacity" title="円錐の頂点付近（市場）が一度に受け入れられる資源の最大数。">頂点最大容量 <span class="parameter-value" id="vertexCapacity-value">5</span></label>
        <input type="range" id="vertexCapacity" min="1" max="15" value="5" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="capacityRadius" title="頂点容量制限が適用される、頂点からの半径。">容量制限半径 <span class="parameter-value" id="capacityRadius-value">2</span></label>
        <input type="range" id="capacityRadius" min="1" max="5" value="2" step="0.5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="congestionEffect" title="頂点付近の混雑が資源の上昇を妨げる度合い（1に近いほど妨げない）。">混雑効果係数 <span class="parameter-value" id="congestionEffect-value">0.8</span></label>
        <input type="range" id="congestionEffect" min="0.3" max="1.0" value="0.8" step="0.05" oninput="updateParameters()">
      </div>
    </div>
    <div class="button-group">
      <button class="btn" onclick="startSimulation()">開始</button>
      <button class="btn btn-secondary" onclick="pauseSimulation()">一時停止</button>
      <button class="btn btn-secondary" onclick="resetSimulation()">リセット</button>
      <button class="btn" onclick="exportCSV()">CSV出力</button>
    </div>
  </div>
</div>
<script>
let scene, camera, renderer, coneGroup, controls;
let particles = [], nextParticleId = 0;
let animationId;
let simulationState = {
  isRunning: false, isPaused: false, elapsedTime: 0, lastSpawnTime: 0,
  totalSpawned: 0, successCount: 0, log: []
};
const coneHeight = 40, coneRadius = 20;
const parameters = {
  initialPlacementStrategy: 'random',
  initialParticles: 20,
  timeScale: 0.1,
  spawnInterval: 0.5,
  batchSize: 3,
  trtForce: 0.015,
  trtAcceleration: 1.0,
  tippingPoint: 0.7,
  reuseRate: 0.2,
  praForce: 0.02,
  praDiversity: 1.0,
  multiGravityEnabled: true,
  centralConvergence: 0.03,
  clusterConvergence: 0.04,
  clusterInertia: 0.015,
  marketPull: 0.02,
  peerAttraction: 0.01,
  attractionRange: 5,
  clusterThreshold: 3,
  successThreshold: 38,
  envBiasEnabled: true,
  coneTiltX: 0,
  coneTiltZ: 0,
  vertexCapacity: 5,
  capacityRadius: 2,
  congestionEffect: 0.8
};

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(40, 40, 40);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, coneHeight/2, 0);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  const gridHelper = new THREE.GridHelper(coneRadius * 2, 20, 0x888888, 0xcccccc);
  gridHelper.material.opacity = 0.2;
  gridHelper.material.transparent = true;
  scene.add(gridHelper);

  coneGroup = new THREE.Group();
  scene.add(coneGroup);

  // 円錐輪郭のみ（底面円＋側面の4本線）
  const baseGeom = new THREE.CircleGeometry(coneRadius, 64);
  const baseMat = new THREE.LineBasicMaterial({ color: 0x222, linewidth: 1 });
  const baseLine = new THREE.Line(baseGeom, baseMat);
  baseLine.rotation.x = -Math.PI/2;
  baseLine.position.y = 0;
  coneGroup.add(baseLine);

  // 側面の4本の細い線
  for(let i=0;i<4;i++){
    const theta = (i/4) * Math.PI*2;
    const x = Math.cos(theta)*coneRadius, z = Math.sin(theta)*coneRadius;
    const points = [new THREE.Vector3(x,0,z), new THREE.Vector3(0,coneHeight,0)];
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color:0x222, linewidth:1 }));
    coneGroup.add(line);
  }

  // 発展段階の底面円（淡い半透明）
  const coneSegments = 4, segmentHeight = coneHeight / coneSegments;
  const colors = [0x8b5cf6, 0x0000FF, 0xFFFF00, 0xFF0000];
  for (let i = 0; i < coneSegments; i++) {
    const bottomY = i * segmentHeight;
    const bottomRadius = coneRadius * (1 - bottomY / coneHeight);
    const diskGeometry = new THREE.CircleGeometry(bottomRadius, 32);
    const diskMaterial = new THREE.MeshBasicMaterial({ color: colors[i], side: THREE.DoubleSide, transparent: true, opacity: 0.13 });
    const disk = new THREE.Mesh(diskGeometry, diskMaterial);
    disk.rotation.x = -Math.PI / 2;
    disk.position.y = bottomY;
    coneGroup.add(disk);
  }

  window.addEventListener('resize', onWindowResize);
  setupUIListeners();
  updateParameters();
  resetSimulation();
  animate();
}

class Particle {
  constructor(id, position) {
    this.id = id;
    this.position = position.clone();
    this.velocity = new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
    this.age = 0;
    this.isActive = true;
    this.succeeding = false;
    this.succeedingTime = 0;
    this.bubbling = false;
    this.bubbleTime = 0;
    this.inCluster = false;
    this.clusterCenter = null;
    const geometry = new THREE.SphereGeometry(0.3, 16, 16);
    const material = new THREE.MeshPhongMaterial({color:this.getColor()});
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.copy(this.position);
    scene.add(this.mesh);
  }
  update(deltaTime) {
    // 泡エフェクトで消失
    if(this.bubbling){
      this.bubbleTime += deltaTime;
      const dur = 0.5;
      if(this.bubbleTime >= dur){
        this.bubbling = false;
        if(this.mesh.parent) scene.remove(this.mesh);
      }else{
        const p = this.bubbleTime/dur;
        this.mesh.scale.set(1+2*p,1+2*p,1+2*p);
        this.mesh.material.opacity = 0.7*(1-p);
        this.mesh.material.transparent = true;
        this.mesh.material.needsUpdate = true;
      }
      return;
    }
    if(this.succeeding){
      this.succeedingTime += deltaTime;
      const dur = 0.5;
      if(this.succeedingTime >= dur){
        this.succeeding = false;
        if(this.mesh.parent) scene.remove(this.mesh);
      }else{
        const p = this.succeedingTime/dur;
        this.mesh.scale.set(1+2*p,1+2*p,1+2*p);
        this.mesh.material.opacity = 1-p;
        this.mesh.material.transparent = true;
        this.mesh.material.needsUpdate = true;
      }
      return;
    }
    if (!this.isActive) return;

    const hRatio = this.position.y / coneHeight;
    // TRT
    this.velocity.y += parameters.trtForce * (1-hRatio) * (hRatio < parameters.tippingPoint ? 1 : parameters.trtAcceleration) * deltaTime;
    // PRA
    this.velocity.x += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;
    this.velocity.z += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;

    // クラスター凝集
    if(parameters.multiGravityEnabled){
      // クラスター中心への吸引
      let neighbors = particles.filter(p=>p!==this && p.isActive && this.position.distanceTo(p.position)<parameters.attractionRange);
      if(neighbors.length >= parameters.clusterThreshold){
        this.inCluster = true;
        // クラスター中心を算出
        let center = new THREE.Vector3();
        neighbors.forEach(n=>center.add(n.position));
        center.divideScalar(neighbors.length);
        this.clusterCenter = center;
        // クラスター中心へ吸着
        let toCluster = center.clone().sub(this.position).normalize();
        this.velocity.add(toCluster.multiplyScalar(parameters.clusterConvergence * deltaTime));
        // 慣性
        this.velocity.multiplyScalar(1+parameters.clusterInertia*deltaTime);
      }else{
        this.inCluster = false;
        this.clusterCenter = null;
      }
      // 中央収束
      const toCenter = new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize();
      this.velocity.add(toCenter.multiplyScalar(parameters.centralConvergence * hRatio * deltaTime));
      // 市場引力
      if(hRatio > 0.7){
        const toVertex = new THREE.Vector3(0, parameters.successThreshold - this.position.y, 0);
        this.velocity.add(toVertex.normalize().multiplyScalar(parameters.marketPull * deltaTime));
      }
    }

    // 頂点容量制限
    if (parameters.envBiasEnabled && this.position.y > (coneHeight - parameters.capacityRadius * 2)) {
      let congestion = 0;
      particles.forEach(p => {
        if (p.id !== this.id && p.isActive && this.position.distanceTo(p.position) < parameters.capacityRadius) {
          congestion++;
        }
      });
      if (congestion >= parameters.vertexCapacity) {
        this.velocity.y *= parameters.congestionEffect;
      }
    }
    this.position.add(this.velocity.clone().multiplyScalar(deltaTime * parameters.timeScale * 10));
    // 境界
    const maxRadius = coneRadius * (1 - this.position.y/coneHeight);
    if (Math.sqrt(this.position.x**2 + this.position.z**2) > maxRadius) {
      this.disappear();
      return;
    }
    if (this.position.y >= parameters.successThreshold) {
      this.succeed();
      return;
    }
    if (this.position.y < 0) {
      this.disappear();
      return;
    }
    if (this.isActive) {
      this.mesh.position.copy(this.position);
      this.mesh.material.color.set(this.getColor());
      simulationState.log.push({
        time: simulationState.elapsedTime.toFixed(2),
        id: this.id, x: this.position.x.toFixed(2), y: this.position.y.toFixed(2), z: this.position.z.toFixed(2)
      });
    }
  }
  getColor() {
    const h = this.position.y/coneHeight;
    if (h<0.25) return 0x8b5cf6;
    if (h<0.5) return 0x0000FF;
    if (h<0.75) return 0xFFFF00;
    return 0xFF0000;
  }
  succeed() {
    if(!this.isActive) return;
    this.isActive = false;
    this.succeeding = true;
    simulationState.successCount++;
  }
  disappear() {
    if(!this.isActive) return;
    this.isActive = false;
    // 再利用ロジック
    if(Math.random() < parameters.reuseRate){
      // 再利用: 新たな位置で復活
      const angle = Math.random()*Math.PI*2, radius = Math.random()*coneRadius*0.9;
      this.position.set(Math.cos(angle)*radius,1,Math.sin(angle)*radius);
      this.velocity.set((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
      this.isActive = true;
      this.bubbling = false;
      this.bubbleTime = 0;
      return;
    }
    // 泡エフェクト
    this.bubbling = true;
    this.bubbleTime = 0;
  }
}

function createInitialParticles() {
  particles.forEach(p => { if(p.mesh && p.mesh.parent) scene.remove(p.mesh); });
  particles = [];
  nextParticleId = 0;
  const count = parameters.initialParticles;
  switch(parameters.initialPlacementStrategy) {
    case 'focused':
      const focus = new THREE.Vector3((Math.random()-0.5)*10, 1, (Math.random()-0.5)*10);
      for(let i=0;i<count;i++){ const pos = focus.clone().add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).multiplyScalar(3)); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    case 'diversified':
      for(let i=0;i<count;i++){ const angle = (i/count)*Math.PI*2; const radius = coneRadius*0.8; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    case 'clustered':
      const clusters = 3;
      for(let i=0;i<clusters;i++){ const angle = (i/clusters)*Math.PI*2; const radius = coneRadius*0.6; const center = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); for(let j=0;j<Math.floor(count/clusters);j++){ const pos = center.clone().add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).multiplyScalar(4)); particles.push(new Particle(nextParticleId++, pos)); }}
      break;
    case 'edge':
      for(let i=0;i<count;i++){ const angle = Math.random()*Math.PI*2; const radius = coneRadius*0.95; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    default:
      for(let i=0;i<count;i++){ const angle = Math.random()*Math.PI*2; const radius = Math.random()*coneRadius*0.9; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
  }
  simulationState.totalSpawned += count;
}

function startSimulation() {
  if(simulationState.isRunning && !simulationState.isPaused) return;
  if(!simulationState.isRunning) resetSimulation();
  simulationState.isRunning = true;
  simulationState.isPaused = false;
}
function pauseSimulation() { if(simulationState.isRunning) simulationState.isPaused = !simulationState.isPaused; }
function resetSimulation() {
  simulationState.isRunning = false;
  simulationState.isPaused = false;
  simulationState.elapsedTime = 0;
  simulationState.lastSpawnTime = 0;
  simulationState.totalSpawned = 0;
  simulationState.successCount = 0;
  simulationState.log = [];
  createInitialParticles();
  updateStats();
}
const clock = new THREE.Clock();
function animate() {
  animationId = requestAnimationFrame(animate);
  controls.update();
  if(simulationState.isRunning && !simulationState.isPaused) {
    const deltaTime = clock.getDelta();
    simulationState.elapsedTime += deltaTime * parameters.timeScale;
    if(simulationState.elapsedTime - simulationState.lastSpawnTime >= parameters.spawnInterval) {
      for(let i=0;i<parameters.batchSize;i++){
        const angle = Math.random()*Math.PI*2; const radius = Math.random()*coneRadius*0.9;
        particles.push(new Particle(nextParticleId++, new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius)));
      }
      simulationState.totalSpawned += parameters.batchSize;
      simulationState.lastSpawnTime = simulationState.elapsedTime;
    }
    particles.forEach(p => p.update(deltaTime));
    particles = particles.filter(p => p.isActive || p.succeeding || p.bubbling);
    updateStats();
  } else {
    clock.getDelta();
  }
  renderer.render(scene, camera);
}
function updateParameters() {
  document.querySelectorAll('input, select').forEach(el => {
    if (el.type === 'checkbox') parameters[el.id] = el.checked;
    else parameters[el.id] = el.type === 'range' ? parseFloat(el.value) : el.value;
    const valEl = document.getElementById(el.id+'-value');
    if(valEl) valEl.textContent = parameters[el.id];
  });
  coneGroup.rotation.set(THREE.MathUtils.degToRad(parameters.coneTiltX), 0, THREE.MathUtils.degToRad(parameters.coneTiltZ));
  const multiGravityGroup = document.querySelector('#multiGravityEnabled').closest('.parameter-group');
  multiGravityGroup.querySelectorAll('input[type=range]').forEach(input => input.disabled = !parameters.multiGravityEnabled);
  const envBiasGroup = document.querySelector('#envBiasEnabled').closest('.parameter-group');
  envBiasGroup.querySelectorAll('input[type=range]').forEach(input => input.disabled = !parameters.envBiasEnabled);
}
function updateStats() {
  document.getElementById('sim-time').textContent = simulationState.elapsedTime.toFixed(1);
  document.getElementById('success-count').textContent = simulationState.successCount;
  document.getElementById('active-particles').textContent = particles.filter(p=>p.isActive).length;
  document.getElementById('total-spawned').textContent = simulationState.totalSpawned;
  const rate = simulationState.totalSpawned>0?(simulationState.successCount/simulationState.totalSpawned)*100:0;
  document.getElementById('success-rate').textContent = rate.toFixed(1)+'%';
}
function exportCSV() {
  if(simulationState.log.length===0){ alert('エクスポートするデータがありません。'); return; }
  let csv = 'time,particle_id,x,y,z\n';
  simulationState.log.forEach(row=>{ csv += `${row.time},${row.id},${row.x},${row.y},${row.z}\n`; });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'simulation_data.csv';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function setupUIListeners() {
  document.querySelectorAll('input, select').forEach(el => el.addEventListener('input', updateParameters));
  document.getElementById('toggle-control-panel').addEventListener('click', () => {
    const content = document.querySelector('#control-panel .content-wrapper');
    const button = document.getElementById('toggle-control-panel');
    content.style.display = content.style.display === 'none' ? '' : 'none';
    button.textContent = content.style.display === 'none' ? '[+]' : '[-]';
  });
}
init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TRTãƒ»PRA ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ - æœ€é©åŒ–ç‰ˆ</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
body { margin:0; font-family: Arial,sans-serif; background:#f0f0f0; overflow:hidden; }
#canvas-container { position:relative; width:100vw; height:100vh; cursor: move; }
.panel { position:absolute; background:rgba(255,255,255,0.98); padding:20px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; max-height:90vh; overflow-y:auto; scrollbar-width: thin; }
#control-panel { bottom:20px; left:20px; width:400px; }
#stats-panel { top:20px; right:20px; width:320px; font-size:13px; color:#1f2937; }
h1,h2 { margin-top:0; color:#1f2937; }
h1 { font-size:20px; display: flex; justify-content: space-between; align-items: center; }
h2 { font-size:16px; border-bottom:1px solid #e5e7eb; padding-bottom:8px; margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;}
.parameter-group { margin-bottom:20px; border-radius: 6px; padding: 15px; }
.parameter-group.trt { border-left: 4px solid #3b82f6; background: rgba(59, 130, 246, 0.05); }
.parameter-group.pra { border-left: 4px solid #10b981; background: rgba(16, 185, 129, 0.05); }
.parameter { margin-bottom:10px; }
.parameter label { display:block; font-size:12px; color:#4b5563; margin-bottom:4px; font-weight:600; cursor: help; }
input[type=range], input[type=number], select { width:100%; box-sizing: border-box; }
input:disabled, select:disabled, button:disabled { opacity: 0.5; cursor: not-allowed; }
.parameter-value { font-size:11px; color:#6b7280; margin-left:8px; float:right; }
.button-group { display:flex; gap:8px; flex-wrap:wrap; margin-top:15px; }
button.btn { flex-grow:1; padding:8px 12px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer; font-size:13px; transition:background 0.2s; }
button.btn:hover:not(:disabled) { background:#2563eb; }
button.btn-secondary { background:#6b7280; }
button.btn-secondary:hover:not(:disabled) { background:#4b5563; }
#toggle-control-panel { font-size: 14px; background: none; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px 8px; font-weight: bold; }
h2 input[type=checkbox] { margin-left: 10px; transform: scale(1.2); cursor: pointer;}
.legend { position:absolute; top:20px; left:20px; background:rgba(255,255,255,0.98); padding:15px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; font-size:12px; color:#1f2937; }
.legend-item { display:flex; align-items:center; margin-bottom:5px; }
.legend-color { width:15px; height:15px; margin-right:8px; border-radius:3px; }
#scenario-list { list-style-type: none; padding-left: 0; font-size: 12px; max-height: 100px; overflow-y: auto; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; margin-top: 10px; }
#scenario-list li { padding: 4px 8px; border-bottom: 1px solid #e5e7eb; cursor: pointer; }
#scenario-list li:last-child { border-bottom: none; }
#scenario-list li:hover { background: #e5e7eb; }
.theory-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; margin-left: 8px; }
.theory-badge.trt { background: #3b82f6; color: white; }
.theory-badge.pra { background: #10b981; color: white; }
.error-message { background: #fee; border: 1px solid #fcc; color: #c33; padding: 10px; border-radius: 6px; margin: 10px 0; }
.success-message { background: #efe; border: 1px solid #cfc; color: #363; padding: 10px; border-radius: 6px; margin: 10px 0; }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="legend-panel" class="legend">
  <h2>è³‡æºã®ç™ºå±•æ®µéš</h2>
  <div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #aaffaa, #66cc66)"></div>ç´”ç²‹æ¢ç´¢ (ç·‘)</div>
  <div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #ffffaa, #ffcc00)"></div>ç§»è¡ŒæœŸ (é»„)</div>
  <div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #ffccee, #ff69b4)"></div>å¿œç”¨é–‹ç™º (ãƒ”ãƒ³ã‚¯)</div>
  <div class="legend-item"><div class="legend-color" style="background: linear-gradient(to right, #ffaaaa, #cc0000)"></div>å¸‚å ´æ´»ç”¨ (èµ¤)</div>
</div>
<div id="stats-panel" class="panel">
  <h2>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æŒ‡æ¨™</h2>
  <div>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“: <span id="sim-time">0.0</span> å¹´</div>
  <div>å¸‚å ´åŒ–æˆåŠŸæ•°: <span id="success-count">0</span></div>
  <div>æˆåŠŸç‡: <span id="success-rate">0.0%</span></div>
  <div>æ´»æ€§è³‡æºæ•°: <span id="active-particles">0</span></div>
  <div>ç´¯è¨ˆæŠ•å…¥è³‡æº: <span id="total-spawned">0</span></div>
  <div>å†åˆ©ç”¨è³‡æºæ•°: <span id="recycled-count">0</span></div>
  <div>ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°: <span id="current-clusters">0</span></div>
  <div>ç´¯è¨ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆ: <span id="total-clusters">0</span></div>
  <div>æœ€å¤§ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚µã‚¤ã‚º: <span id="max-cluster-size">0</span></div>
</div>
<div id="control-panel" class="panel">
  <h1>TRTãƒ»PRA ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿<button id="toggle-control-panel">[-]</button></h1>
  <div class="content-wrapper">
    <div id="message-area"></div>
    
    <div class="parameter-group">
      <h2>è¦–è¦šåŒ–å¼·åŒ–è¨­å®š</h2>
      <div class="parameter">
        <label for="showTrails">è»Œè·¡è¡¨ç¤º <input type="checkbox" id="showTrails" checked onchange="updateParameters()"></label>
      </div>
      <div class="parameter">
        <label for="trailLength">è»Œè·¡é•·ã• <span class="parameter-value" id="trailLength-value">10</span></label>
        <input type="range" id="trailLength" min="3" max="20" value="10" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="trailOpacity">è»Œè·¡æ¿ƒåº¦ <span class="parameter-value" id="trailOpacity-value">0.8</span></label>
        <input type="range" id="trailOpacity" min="0.2" max="1.0" value="0.8" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="glowIntensity">ç™ºå…‰å¼·åº¦ <span class="parameter-value" id="glowIntensity-value">0.5</span></label>
        <input type="range" id="glowIntensity" min="0" max="1.0" value="0.5" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="pulseEffect">ãƒ‘ãƒ«ã‚¹åŠ¹æœ <input type="checkbox" id="pulseEffect" checked onchange="updateParameters()"></label>
      </div>
      <div class="parameter">
        <label for="clusterEffect">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ <input type="checkbox" id="clusterEffect" checked onchange="updateParameters()"></label>
      </div>
      <div class="parameter">
        <label for="cameraMode">ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰</label>
        <select id="cameraMode" onchange="updateParameters()">
          <option value="free">è‡ªç”±è¦–ç‚¹</option>
          <option value="side">ã‚µã‚¤ãƒ‰ãƒ“ãƒ¥ãƒ¼</option>
          <option value="tracking">è‡ªå‹•è¿½è·¡</option>
        </select>
      </div>
    </div>
    
    <div class="parameter-group">
      <h2>ã‚·ãƒŠãƒªã‚ªæ¯”è¼ƒ</h2>
       <div class="parameter">
        <label for="comparisonDuration">æ¯”è¼ƒå®Ÿè¡Œæ™‚é–“ (å¹´)</label>
        <input type="number" id="comparisonDuration" value="20" min="5" max="100" step="1">
      </div>
      <div class="button-group">
        <button class="btn btn-secondary" onclick="addScenario()">ç¾åœ¨ã®è¨­å®šã‚’ã‚·ãƒŠãƒªã‚ªè¿½åŠ </button>
      </div>
      <ul id="scenario-list"></ul>
      <div class="button-group">
         <button class="btn" id="runComparisonBtn" onclick="runComparison()" disabled>æ¯”è¼ƒå®Ÿè¡Œ</button>
         <button class="btn" id="exportComparisonBtn" onclick="exportComparisonCSV()" disabled>æ¯”è¼ƒçµæœã‚’CSVå‡ºåŠ›</button>
      </div>
    </div>
    
    <div class="parameter-group">
      <h2>æˆ¦ç•¥çš„åˆæœŸé…ç½®</h2>
      <div class="parameter">
        <label for="initialPlacementStrategy">åˆæœŸé…ç½®æˆ¦ç•¥</label>
        <select id="initialPlacementStrategy" onchange="updateParameters()">
          <option value="random">ãƒ©ãƒ³ãƒ€ãƒ </option>
          <option value="focused">é›†ä¸­å‹</option>
          <option value="diversified">åˆ†æ•£å‹</option>
          <option value="clustered">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å‹</option>
          <option value="edge">ã‚¨ãƒƒã‚¸æ¢ç´¢å‹</option>
        </select>
      </div>
      <div class="parameter">
        <label for="initialParticles">åˆæœŸè³‡æºæ•° <span class="parameter-value" id="initialParticles-value">20</span></label>
        <input type="range" id="initialParticles" min="1" max="100" value="20" step="1" oninput="updateParameters()">
      </div>
    </div>
    
    <div class="parameter-group">
      <h2>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡</h2>
      <div class="parameter">
        <label for="timeScale">æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ« <span class="parameter-value" id="timeScale-value">0.1</span></label>
        <input type="range" id="timeScale" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="spawnInterval">è³‡æºæŠ•å…¥é–“éš” (å¹´) <span class="parameter-value" id="spawnInterval-value">0.5</span></label>
        <input type="range" id="spawnInterval" min="0.1" max="2.0" value="0.5" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="batchSize">æŠ•å…¥ãƒãƒƒãƒã‚µã‚¤ã‚º <span class="parameter-value" id="batchSize-value">3</span></label>
        <input type="range" id="batchSize" min="1" max="10" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    
    <div class="parameter-group trt">
      <h2>TRTãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ <span class="theory-badge trt">Temporal Resource Transition</span></h2>
      <div class="parameter">
        <label for="trtForce" title="è³‡æºã‚’å††éŒã®ä¸Šæ–¹å‘ï¼ˆå¸‚å ´åŒ–æ–¹å‘ï¼‰ã¸æŠ¼ã—ä¸Šã’ã‚‹åŸºæœ¬çš„ãªåŠ›ã€‚">å‚ç›´æ¨é€²åŠ› <span class="parameter-value" id="trtForce-value">0.015</span></label>
        <input type="range" id="trtForce" min="0" max="0.05" value="0.015" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="trtAcceleration" title="ãƒ†ã‚£ãƒƒãƒ”ãƒ³ã‚°ãƒã‚¤ãƒ³ãƒˆã‚’è¶…ãˆãŸè³‡æºã®ä¸Šæ˜‡ã‚’åŠ é€Ÿã•ã›ã‚‹åº¦åˆã„ã€‚">ä¸Šæ˜‡åŠ é€Ÿåº¦ <span class="parameter-value" id="trtAcceleration-value">1.0</span></label>
        <input type="range" id="trtAcceleration" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>

    <div class="parameter-group pra">
      <h2>PRAãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ <span class="theory-badge pra">Parallel Resource Allocation</span></h2>
      <div class="parameter">
        <label for="praForce" title="è³‡æºãŒæ°´å¹³æ–¹å‘ã«ãƒ©ãƒ³ãƒ€ãƒ ã«ç§»å‹•ã™ã‚‹åŠ›ã€‚æ¢ç´¢ç¯„å›²ã®æ‹¡å¤§ã«å¯„ä¸ã€‚">æ°´å¹³æ‹¡æ•£åŠ› <span class="parameter-value" id="praForce-value">0.02</span></label>
        <input type="range" id="praForce" min="0" max="0.05" value="0.02" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="praDiversity" title="æ°´å¹³æ–¹å‘ã¸ã®æ‹¡æ•£ã®å¤šæ§˜æ€§ã‚’ç¶­æŒã™ã‚‹ä¿‚æ•°ã€‚">å¤šæ§˜æ€§ç¶­æŒä¿‚æ•° <span class="parameter-value" id="praDiversity-value">1.0</span></label>
        <input type="range" id="praDiversity" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>

    <div class="parameter-group">
      <h2>ç’°å¢ƒåˆ¶ç´„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h2>
      <div class="parameter">
        <label for="tippingPoint" title="ä¸Šæ˜‡åŠ é€Ÿåº¦ãŒåƒãå§‹ã‚ã‚‹å††éŒã®é«˜ã•ã®é–¾å€¤ã€‚">ãƒ†ã‚£ãƒƒãƒ”ãƒ³ã‚°ãƒã‚¤ãƒ³ãƒˆ <span class="parameter-value" id="tippingPoint-value">0.7</span></label>
        <input type="range" id="tippingPoint" min="0.5" max="0.9" value="0.7" step="0.05" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="marketPull" title="è³‡æºãŒå††éŒã®é ‚ç‚¹ï¼ˆå¸‚å ´åŒ–ï¼‰ã«å¼•ãå¯„ã›ã‚‰ã‚Œã‚‹åŠ›ã€‚å¸‚å ´ã®é­…åŠ›ã‚’ç¤ºã™ã€‚">å¸‚å ´å¼•åŠ› <span class="parameter-value" id="marketPull-value">0.02</span></label>
        <input type="range" id="marketPull" min="0" max="0.05" value="0.02" step="0.005" oninput="updateParameters()">
      </div>
    </div>

    <div class="parameter-group">
      <h2>å¾ªç’°ãƒ¡ã‚«ãƒ‹ã‚ºãƒ </h2>
      <div class="parameter">
        <label for="resourceRecyclingRate" title="å¤±æ•—ã—ãŸè³‡æºãŒå†åˆ©ç”¨ã•ã‚Œã‚‹ç¢ºç‡ã€‚å¾ªç’°å‹ã‚¤ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¿ƒé€²ã™ã‚‹ã€‚">è³‡æºå†åˆ©ç”¨ç‡ <span class="parameter-value" id="resourceRecyclingRate-value">0.2</span></label>
        <input type="range" id="resourceRecyclingRate" min="0" max="1.0" value="0.2" step="0.05" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="recyclingDelay" title="è³‡æºãŒå†åˆ©ç”¨ã•ã‚Œã‚‹ã¾ã§ã®é…å»¶æ™‚é–“ï¼ˆå¹´ï¼‰ã€‚">å†åˆ©ç”¨é…å»¶æ™‚é–“ <span class="parameter-value" id="recyclingDelay-value">1.0</span></label>
        <input type="range" id="recyclingDelay" min="0.1" max="5.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>

    <div class="parameter-group">
      <h2>å¤šé‡é‡åŠ›æºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ <input type="checkbox" id="multiGravityEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="centralConvergence" title="è³‡æºãŒå††éŒã®ä¸­å¿ƒã«å‘ã‹ã†åŠ›ã€‚é–‹ç™ºã®æ–¹å‘æ€§ã‚’ä¸­å¤®ã«é›†ç´„ã•ã›ã‚‹ã€‚">ä¸­å¤®åæŸåŠ› <span class="parameter-value" id="centralConvergence-value">0.03</span></label>
        <input type="range" id="centralConvergence" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterConvergence" title="å½¢æˆã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ï¼ˆæŠ€è¡“ç¾¤ï¼‰ã®ä¸­å¿ƒã«è³‡æºãŒé›†ã¾ã‚‹åŠ›ã€‚">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å†…åæŸåŠ› <span class="parameter-value" id="clusterConvergence-value">0.04</span></label>
        <input type="range" id="clusterConvergence" min="0" max="0.1" value="0.04" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="peerAttraction" title="è³‡æºåŒå£«ãŒäº’ã„ã«å¼•ãåˆã†åŠ›ã€‚çŸ¥è­˜ã®å…±æœ‰ã‚„å”æ¥­ã‚’æ¨¡å€£ã™ã‚‹ã€‚">ç²’å­é–“å¼•åŠ› <span class="parameter-value" id="peerAttraction-value">0.03</span></label>
        <input type="range" id="peerAttraction" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="attractionRange" title="ç²’å­é–“å¼•åŠ›ãŒåƒãæœ€å¤§ã®è·é›¢ã€‚">å¼•åŠ›ä½œç”¨ç¯„å›² <span class="parameter-value" id="attractionRange-value">6</span></label>
        <input type="range" id="attractionRange" min="2" max="15" value="6" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterThreshold" title="ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã¨è¦‹ãªã•ã‚Œã‚‹ãŸã‚ã«å¿…è¦ãªè¿‘æ¥è³‡æºã®æœ€å°æ•°ã€‚">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆé–¾å€¤ <span class="parameter-value" id="clusterThreshold-value">3</span></label>
        <input type="range" id="clusterThreshold" min="2" max="8" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    
    <div class="parameter-group">
      <h2>ç’°å¢ƒãƒã‚¤ã‚¢ã‚¹ãƒ»é ‚ç‚¹å®¹é‡åˆ¶é™ <input type="checkbox" id="envBiasEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="coneTiltX" title="å††éŒå…¨ä½“ã‚’Xè»¸å‘¨ã‚Šã«å‚¾ã‘ã‚‹ã€‚ç‰¹å®šåˆ†é‡ã¸ã®æŠ€è¡“é–‹ç™ºã®åã‚Šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã€‚">å††éŒå‚¾æ–œXè»¸ <span class="parameter-value" id="coneTiltX-value">0</span></label>
        <input type="range" id="coneTiltX" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="coneTiltZ" title="å††éŒå…¨ä½“ã‚’Zè»¸å‘¨ã‚Šã«å‚¾ã‘ã‚‹ã€‚ç‰¹å®šåˆ†é‡ã¸ã®æŠ€è¡“é–‹ç™ºã®åã‚Šã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã€‚">å††éŒå‚¾æ–œZè»¸ <span class="parameter-value" id="coneTiltZ-value">0</span></label>
        <input type="range" id="coneTiltZ" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="vertexCapacity" title="å††éŒã®é ‚ç‚¹ä»˜è¿‘ï¼ˆå¸‚å ´ï¼‰ãŒä¸€åº¦ã«å—ã‘å…¥ã‚Œã‚‰ã‚Œã‚‹è³‡æºã®æœ€å¤§æ•°ã€‚">é ‚ç‚¹æœ€å¤§å®¹é‡ <span class="parameter-value" id="vertexCapacity-value">5</span></label>
        <input type="range" id="vertexCapacity" min="1" max="15" value="5" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="capacityRadius" title="é ‚ç‚¹å®¹é‡åˆ¶é™ãŒé©ç”¨ã•ã‚Œã‚‹ã€é ‚ç‚¹ã‹ã‚‰ã®åŠå¾„ã€‚">å®¹é‡åˆ¶é™åŠå¾„ <span class="parameter-value" id="capacityRadius-value">2</span></label>
        <input type="range" id="capacityRadius" min="1" max="5" value="2" step="0.5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="congestionEffect" title="é ‚ç‚¹ä»˜è¿‘ã®æ··é›‘ãŒè³‡æºã®ä¸Šæ˜‡ã‚’å¦¨ã’ã‚‹åº¦åˆã„ï¼ˆ1ã«è¿‘ã„ã»ã©å¦¨ã’ãªã„ï¼‰ã€‚">æ··é›‘åŠ¹æœä¿‚æ•° <span class="parameter-value" id="congestionEffect-value">0.8</span></label>
        <input type="range" id="congestionEffect" min="0.3" max="1.0" value="0.8" step="0.05" oninput="updateParameters()">
      </div>
    </div>
    
    <div class="button-group">
      <button class="btn" onclick="startSimulation()">é–‹å§‹</button>
      <button class="btn btn-secondary" onclick="pauseSimulation()">ä¸€æ™‚åœæ­¢</button>
      <button class="btn btn-secondary" onclick="resetSimulation()">ãƒªã‚»ãƒƒãƒˆ</button>
      <button class="btn" onclick="exportCSV()">ãƒ­ã‚°CSVå‡ºåŠ›</button>
    </div>
  </div>
</div>

<script>
// OrbitControls ç°¡æ˜“å®Ÿè£…ï¼ˆThree.jså‘ã‘ï¼‰
THREE.OrbitControls = function(object, domElement) {
  this.object = object;
  this.domElement = domElement || document;
  this.target = new THREE.Vector3();
  this.enableDamping = false;
  
  var scope = this;
  var isMouseDown = false;
  var lastMouse = new THREE.Vector2();
  var spherical = new THREE.Spherical();
  var sphericalDelta = new THREE.Spherical();
  
  function onMouseDown(event) {
    isMouseDown = true;
    lastMouse.set(event.clientX, event.clientY);
  }
  
  function onMouseMove(event) {
    if (!isMouseDown) return;
    var deltaX = event.clientX - lastMouse.x;
    var deltaY = event.clientY - lastMouse.y;
    sphericalDelta.theta -= deltaX * 0.01;
    sphericalDelta.phi -= deltaY * 0.01;
    lastMouse.set(event.clientX, event.clientY);
  }
  
  function onMouseUp(event) {
    isMouseDown = false;
  }
  
  this.update = function() {
    var offset = new THREE.Vector3();
    offset.copy(scope.object.position).sub(scope.target);
    spherical.setFromVector3(offset);
    spherical.theta += sphericalDelta.theta;
    spherical.phi += sphericalDelta.phi;
    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
    offset.setFromSpherical(spherical);
    scope.object.position.copy(scope.target).add(offset);
    scope.object.lookAt(scope.target);
    if (scope.enableDamping) {
      sphericalDelta.theta *= 0.95;
      sphericalDelta.phi *= 0.95;
    } else {
      sphericalDelta.set(0, 0, 0);
    }
  };
  
  domElement.addEventListener('mousedown', onMouseDown);
  domElement.addEventListener('mousemove', onMouseMove);
  domElement.addEventListener('mouseup', onMouseUp);
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å®£è¨€ï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆã‚’è¿½åŠ ï¼‰
var scene, camera, renderer, coneGroup, controls;
var particles = [], nextParticleId = 0, recycledParticles = [];
var animationId;
var scenarios = [], comparisonResults = [];
var clusterConnections = []; // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¥ç¶šç·šã‚’ç®¡ç†
var clusterEffects = []; // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç®¡ç†

// ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆãƒ‡ãƒ¼ã‚¿
var clusterStats = {
  currentClusters: 0,
  totalClustersFormed: 0,
  maxClusterSize: 0,
  lastDetectionTime: 0
};

var simulationState = {
  isRunning: false, isPaused: true, elapsedTime: 0, lastSpawnTime: 0,
  totalSpawned: 0, successCount: 0, recycledCount: 0, log: []
};

var coneHeight = 40, coneRadius = 20;
var parameters = {};

// ã‚«ãƒ¡ãƒ©ç®¡ç†å¤‰æ•°
var currentCameraMode = 'free';
var cameraTarget = null;
var originalCameraPosition = null;

// è‰²ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
var colorStops = {
    green: new THREE.Color(0x00ff00),
    yellow: new THREE.Color(0xffff00),
    pink: new THREE.Color(0xff69b4),
    red: new THREE.Color(0xff0000)
};

// å¼·åˆ¶çš„ãªã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ  - ç¢ºå®Ÿã«å‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆç‰ˆ
function detectClusters(allParticles, params) {
  console.log('ğŸ” detectClustersé–¢æ•°ãŒå®Ÿè¡Œã•ã‚Œã¾ã—ãŸ');
  
  // åŸºæœ¬çš„ãªå‰ææ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯
  if (!params.clusterEffect) {
    console.log('âŒ clusterEffect ãŒç„¡åŠ¹ã§ã™');
    clusterStats.currentClusters = 0;
    return [];
  }
  
  if (!params.multiGravityEnabled) {
    console.log('âŒ multiGravityEnabled ãŒç„¡åŠ¹ã§ã™');
    clusterStats.currentClusters = 0;
    return [];
  }
  
  var activeParticles = allParticles.filter(function(p) { return p.state === 'active'; });
  console.log('âœ… æ´»æ€§ç²’å­æ•°:', activeParticles.length);
  
  if (activeParticles.length < 2) {
    console.log('âŒ ç²’å­æ•°ä¸è¶³ï¼ˆ2å€‹æœªæº€ï¼‰');
    clusterStats.currentClusters = 0;
    return [];
  }
  
  // ãƒ†ã‚¹ãƒˆç”¨ï¼šæœ€åˆã®æ•°å€‹ã®ç²’å­ã§å¼·åˆ¶çš„ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚’ä½œæˆ
  // ã“ã‚Œã«ã‚ˆã‚Šã€æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®åŸºæœ¬å‹•ä½œã‚’ç¢ºèª
  var clusters = [];
  
  if (activeParticles.length >= 2) {
    console.log('ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä½œæˆã‚’è©¦è¡Œ');
    
    // æœ€åˆã®2-3å€‹ã®ç²’å­ã§å¼·åˆ¶çš„ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä½œæˆ
    var testParticles = activeParticles.slice(0, Math.min(3, activeParticles.length));
    
    // é‡å¿ƒã‚’è¨ˆç®—
    var centerPos = new THREE.Vector3();
    testParticles.forEach(function(p) {
      centerPos.add(p.position);
    });
    centerPos.divideScalar(testParticles.length);
    
    var testCluster = {
      members: testParticles,
      memberIds: testParticles.map(function(p) { return p.id; }),
      center: centerPos,
      intensity: 0.8, // é«˜ã„å¼·åº¦ã§ç¢ºå®Ÿã«è¦‹ãˆã‚‹ã‚ˆã†ã«
      avgDistance: 2.0
    };
    
    clusters.push(testCluster);
    console.log('âœ… ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä½œæˆæˆåŠŸ:', {
      ãƒ¡ãƒ³ãƒãƒ¼æ•°: testParticles.length,
      ä¸­å¿ƒä½ç½®: centerPos,
      å¼·åº¦: testCluster.intensity
    });
  }
  
  // é€šå¸¸ã®æ¤œå‡ºã‚‚ä¸¦è¡Œã—ã¦å®Ÿè¡Œï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
  console.log('ğŸ” é€šå¸¸ã®æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚‚å®Ÿè¡Œä¸­...');
  var attractionRange = params.attractionRange || 6;
  var clusterThreshold = params.clusterThreshold || 3;
  
  console.log('æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:');
  console.log('- attractionRange:', attractionRange);
  console.log('- clusterThreshold:', clusterThreshold);
  
  var processedIds = new Set();
  
  for (var i = 0; i < activeParticles.length && i < 10; i++) { // æœ€åˆã®10å€‹ã®ã¿ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼‰
    var particle = activeParticles[i];
    
    if (processedIds.has(particle.id)) continue;
    
    var neighbors = activeParticles.filter(function(p) {
      var distance = particle.position.distanceTo(p.position);
      return p.id !== particle.id && 
             !processedIds.has(p.id) &&
             distance < attractionRange;
    });
    
    console.log('ç²’å­', particle.id, 'ã®è¿‘å‚æ•°:', neighbors.length, '(é–¾å€¤:', clusterThreshold - 1, ')');
    
    if (neighbors.length >= clusterThreshold - 1) {
      var clusterMembers = [particle].concat(neighbors);
      var memberIds = clusterMembers.map(function(p) { return p.id; });
      
      var centerPos = new THREE.Vector3();
      clusterMembers.forEach(function(p) {
        centerPos.add(p.position);
      });
      centerPos.divideScalar(clusterMembers.length);
      
      var avgDistance = 0;
      for (var j = 0; j < clusterMembers.length; j++) {
        avgDistance += centerPos.distanceTo(clusterMembers[j].position);
      }
      avgDistance /= clusterMembers.length;
      
      var intensity = Math.max(0.2, 1.0 - avgDistance / attractionRange);
      
      clusters.push({
        members: clusterMembers,
        memberIds: memberIds,
        center: centerPos,
        intensity: intensity,
        avgDistance: avgDistance
      });
      
      memberIds.forEach(function(id) {
        processedIds.add(id);
      });
      
      console.log('âœ… é€šå¸¸æ¤œå‡ºã§ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ç™ºè¦‹:', {
        ã‚µã‚¤ã‚º: clusterMembers.length,
        ä¸­å¿ƒ: centerPos,
        å¼·åº¦: intensity.toFixed(2)
      });
    }
  }
  
  // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
  clusterStats.currentClusters = clusters.length;
  if (clusters.length > 0) {
    clusterStats.totalClustersFormed += clusters.length;
    var maxSizeThisTime = Math.max.apply(Math, clusters.map(function(c) { return c.members.length; }));
    if (maxSizeThisTime > clusterStats.maxClusterSize) {
      clusterStats.maxClusterSize = maxSizeThisTime;
    }
  }
  clusterStats.lastDetectionTime = simulationState.elapsedTime;
  
  console.log('ğŸ“Š æœ€çµ‚çµæœ:');
  console.log('- æ¤œå‡ºã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°:', clusters.length);
  console.log('- ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆ:', clusterStats);
  
  return clusters;
}

// å¼·åŒ–ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - çµ±è¨ˆæ©Ÿèƒ½ä»˜ã
function manageClusterEffects(detectedClusters, deltaTime) {
  console.log('ğŸ¬ manageClusterEffects ãŒå®Ÿè¡Œã•ã‚Œã¾ã—ãŸ');
  console.log('- æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°:', detectedClusters.length);
  console.log('- æ—¢å­˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ•°:', clusterEffects.length);
  
  // æ—¢å­˜ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
  var startCount = clusterEffects.length;
  clusterEffects = clusterEffects.filter(function(effect) {
    var stillActive = effect.update(deltaTime);
    if (!stillActive) {
      effect.dispose(); // ãƒªã‚½ãƒ¼ã‚¹ã®é©åˆ‡ãªè§£æ”¾
      console.log('ğŸ­ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†: å¯¿å‘½', effect.maxAge, 'ç§’å®Œäº†');
    }
    return stillActive;
  });
  
  var endCount = clusterEffects.length;
  if (startCount !== endCount) {
    console.log('ğŸ“ˆ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ•°å¤‰åŒ–:', startCount, 'â†’', endCount);
  }
  
  // æ–°ã—ãæ¤œå‡ºã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã«å¯¾ã—ã¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
  detectedClusters.forEach(function(cluster) {
    // åŒã˜ä½ç½®ã«æ—¢å­˜ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒãªã„ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šå¤§ããªç¯„å›²ã§é‡è¤‡ã‚’æ¤œå‡ºï¼‰
    var existingEffect = clusterEffects.find(function(effect) {
      return effect.centerPosition.distanceTo(cluster.center) < 8.0; // ç¯„å›²ã‚’æ‹¡å¤§
    });
    
    if (!existingEffect) {
      // æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
      console.log('ğŸŒŸ æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆä¸­...', {
        center: cluster.center,
        memberCount: cluster.memberIds.length,
        intensity: cluster.intensity
      });
      
      try {
        var newEffect = new ClusterEffect(cluster.center, cluster.memberIds, cluster.intensity);
        clusterEffects.push(newEffect);
        console.log('âœ… ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆæˆåŠŸ');
        
        // æ•™è‚²çš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼šå¤§è¦æ¨¡ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã®ç‰¹åˆ¥ãªé€šçŸ¥
        if (cluster.members.length >= 4) {
          var message = 'å¤§è¦æ¨¡ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆï¼' + cluster.members.length + 'å€‹ã®ç²’å­ãŒå”èª¿';
          console.log('ğŸ‰', message);
          showMessage(message, 'success');
        }
      } catch (error) {
        console.error('ğŸ’¥ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆã§ã‚¨ãƒ©ãƒ¼:', error);
      }
    } else {
      console.log('âšª æ—¢å­˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨é‡è¤‡ã®ãŸã‚ã€æ–°ã—ã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ã‚¹ã‚­ãƒƒãƒ—');
    }
  });
  
  console.log('ğŸª ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ•°:', clusterEffects.length);
}

// ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æœ€é©åŒ–ç‰ˆ - å…‰ã®æŸ±ã‚’å‰Šé™¤ã—ã€ãƒªãƒ³ã‚°ã‚’æ§ãˆã‚ã«èª¿æ•´
function ClusterEffect(centerPos, memberIds, intensity) {
  this.centerPosition = centerPos.clone();
  this.memberIds = memberIds; // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚’æ§‹æˆã™ã‚‹ç²’å­ã®IDé…åˆ—
  this.intensity = intensity; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å¼·åº¦
  this.age = 0; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŒç¶šæ™‚é–“
  this.maxAge = 3.0; // æœ€å¤§æŒç¶šæ™‚é–“ã‚’å»¶é•·ï¼ˆã‚ˆã‚Šé•·ãè¦³å¯Ÿå¯èƒ½ï¼‰
  this.connections = []; // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å†…æ¥ç¶šç·šã®é…åˆ—
  this.visualElements = []; // å…¨ã¦ã®è¦–è¦šè¦ç´ ã‚’ç®¡ç†
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
  console.log('ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆï¼ˆæœ€é©åŒ–ç‰ˆï¼‰:', {
    center: this.centerPosition,
    members: this.memberIds.length,
    intensity: this.intensity
  });
  
  // è»½é‡åŒ–ã•ã‚ŒãŸè¦–è¦šåŒ–ã‚·ã‚¹ãƒ†ãƒ  - ç²’å­ã®è¦–èªæ€§ã‚’é‡è¦–
  this.createOptimizedVisualization();
  
  return this;
}

// æœ€é©åŒ–ã•ã‚ŒãŸè¦–è¦šåŒ–ã‚·ã‚¹ãƒ†ãƒ  - ç²’å­ã‚’é‚ªé­”ã—ãªã„æ§ãˆã‚ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
ClusterEffect.prototype.createOptimizedVisualization = function() {
  // 1. å¤–å´ã®è–„ã„ãƒªãƒ³ã‚°ï¼ˆã•ã‚‰ã«é€æ˜åº¦ã‚’ä¸Šã’ã¦æ§ãˆã‚ã«ï¼‰
  var outerRingGeometry = new THREE.RingGeometry(3, 4, 32); // ã‚µã‚¤ã‚ºã‚’å°‘ã—ç¸®å°
  var outerRingMaterial = new THREE.MeshBasicMaterial({
    color: 0x888888, // ã‚°ãƒ¬ãƒ¼ç³»ã§ç²’å­ã®è‰²ã¨ç«¶åˆã—ãªã„
    transparent: true,
    opacity: 0.2, // é€æ˜åº¦ã‚’å¤§å¹…ã«ä¸Šã’ã¦èƒŒæ™¯ã«æº¶ã‘è¾¼ã‚€ã‚ˆã†ã«ï¼ˆå…ƒï¼š0.8ï¼‰
    side: THREE.DoubleSide
  });
  
  this.outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
  this.outerRing.position.copy(this.centerPosition);
  this.outerRing.rotation.x = -Math.PI / 2; // æ°´å¹³ã«é…ç½®
  scene.add(this.outerRing);
  this.visualElements.push(this.outerRing);
  
  // 2. å†…å´ã®æ›´ã«è–„ã„ãƒªãƒ³ã‚°
  var innerRingGeometry = new THREE.RingGeometry(1.5, 2.5, 24);
  var innerRingMaterial = new THREE.MeshBasicMaterial({
    color: 0xcccccc, // ã‚ˆã‚Šè–„ã„ã‚°ãƒ¬ãƒ¼ã§å­˜åœ¨æ„Ÿã‚’æŠ‘åˆ¶
    transparent: true,
    opacity: 0.15, // éå¸¸ã«è–„ãï¼ˆå…ƒï¼š0.6ï¼‰
    side: THREE.DoubleSide
  });
  
  this.innerRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
  this.innerRing.position.copy(this.centerPosition);
  this.innerRing.rotation.x = -Math.PI / 2;
  scene.add(this.innerRing);
  this.visualElements.push(this.innerRing);
  
  // æ³¨æ„ï¼šå…‰ã®æŸ±ï¼ˆlightPillarï¼‰ã¯å‰Šé™¤ - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã¨è¦–è¦šçš„ãªãƒã‚¤ã‚ºå‰Šæ¸›
  
  // 3. å°ã•ãã¦æ§ãˆã‚ãªãƒãƒ¼ã‚«ãƒ¼çƒï¼ˆã‚µã‚¤ã‚ºã¨é€æ˜åº¦ã‚’èª¿æ•´ï¼‰
  var markerGeometry = new THREE.SphereGeometry(0.5, 12, 12); // ã‚µã‚¤ã‚ºã‚’åŠåˆ†ã«ç¸®å°
  var markerMaterial = new THREE.MeshBasicMaterial({
    color: 0xaaaaaa, // ç›®ç«‹ãŸãªã„ã‚°ãƒ¬ãƒ¼ï¼ˆå…ƒï¼šãƒ”ãƒ³ã‚¯ï¼‰
    transparent: true,
    opacity: 0.4 // é€æ˜åº¦ã‚’ä¸Šã’ã¦æ§ãˆã‚ã«ï¼ˆå…ƒï¼š0.7ï¼‰
  });
  
  this.marker = new THREE.Mesh(markerGeometry, markerMaterial);
  this.marker.position.copy(this.centerPosition);
  this.marker.position.y += 5; // é«˜ã•ã‚’åŠåˆ†ã«ï¼ˆå…ƒï¼š10ï¼‰
  scene.add(this.marker);
  this.visualElements.push(this.marker);
  
  // 4. ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¥ç¶šç·šï¼ˆæ›´ã«æ§ãˆã‚ã«èª¿æ•´ï¼‰
  this.createOptimizedConnections();
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šä½œæˆã•ã‚ŒãŸè¦–è¦šè¦ç´ æ•°ã‚’å ±å‘Š
  console.log('æœ€é©åŒ–è¦–è¦šè¦ç´ ä½œæˆå®Œäº†:', this.visualElements.length + this.connections.length, 'å€‹');
};

// æœ€é©åŒ–ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¥ç¶šç·š - ã‚ˆã‚Šç´°ãã€è–„ã
ClusterEffect.prototype.createOptimizedConnections = function() {
  // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å†…ã®ç²’å­åŒå£«ã‚’çµã¶ç·šã‚’ç”Ÿæˆï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
  for (var i = 0; i < this.memberIds.length && i < 4; i++) { // æ¥ç¶šç·šæ•°ã‚’æ›´ã«åˆ¶é™
    for (var j = i + 1; j < this.memberIds.length && j < 4; j++) {
      var particle1 = particles.find(function(p) { return p.id === this.memberIds[i]; }.bind(this));
      var particle2 = particles.find(function(p) { return p.id === this.memberIds[j]; }.bind(this));
      
      if (particle1 && particle2) {
        var lineGeometry = new THREE.BufferGeometry();
        var positions = [
          particle1.position.x, particle1.position.y, particle1.position.z,
          particle2.position.x, particle2.position.y, particle2.position.z
        ];
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        // ã‚ˆã‚Šè–„ãã€ç›®ç«‹ãŸãªã„æ¥ç¶šç·š
        var lineMaterial = new THREE.LineBasicMaterial({
          color: 0x999999, // ã‚°ãƒ¬ãƒ¼ç³»ã§æ§ãˆã‚ã«ï¼ˆå…ƒï¼šã‚·ã‚¢ãƒ³ï¼‰
          transparent: true,
          opacity: 0.3, // é€æ˜åº¦ã‚’å¤§å¹…ã«ä¸Šã’ã¦ï¼ˆå…ƒï¼š0.8ï¼‰
          linewidth: 1 // ç·šã‚’ç´°ã
        });
        
        var connection = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(connection);
        this.connections.push(connection);
      }
    }
  }
};

// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–° - æœ€é©åŒ–ç‰ˆï¼ˆå…‰ã®æŸ±ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’å‰Šé™¤ï¼‰
ClusterEffect.prototype.update = function(deltaTime) {
  this.age += deltaTime;
  
  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç”Ÿå­˜æ™‚é–“ã«åŸºã¥ãé€æ˜åº¦å¤‰åŒ–ï¼ˆã‚ˆã‚Šç·©ã‚„ã‹ã«ï¼‰
  var lifeRatio = this.age / this.maxAge;
  var opacity = Math.max(0.05, 1.0 - lifeRatio); // æœ€ä½5%ã®é€æ˜åº¦ã‚’ç¶­æŒï¼ˆæ›´ã«è–„ãï¼‰
  
  // å¤–å´ãƒªãƒ³ã‚°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šæ§ãˆã‚ã«ï¼‰
  if (this.outerRing) {
    this.outerRing.rotation.z += deltaTime * 0.5; // å›è»¢é€Ÿåº¦ã‚’é…ãï¼ˆå…ƒï¼š1.5ï¼‰
    this.outerRing.material.opacity = opacity * 0.2; // åŸºæœ¬é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå…ƒï¼š0.8ï¼‰
    
    // è„ˆå‹•åŠ¹æœã‚‚æ§ãˆã‚ã«
    var pulse = 1 + Math.sin(this.age * 2) * 0.1; // æŒ¯å¹…ã‚’å°ã•ãï¼ˆå…ƒï¼š0.2ï¼‰
    this.outerRing.scale.setScalar(pulse);
  }
  
  // å†…å´ãƒªãƒ³ã‚°ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆé€†å›è»¢ã€æ›´ã«æ§ãˆã‚ï¼‰
  if (this.innerRing) {
    this.innerRing.rotation.z -= deltaTime * 1; // å›è»¢é€Ÿåº¦ã‚’é…ãï¼ˆå…ƒï¼š2ï¼‰
    this.innerRing.material.opacity = opacity * 0.15; // åŸºæœ¬é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå…ƒï¼š0.6ï¼‰
    
    // ã‚ˆã‚Šç©ã‚„ã‹ãªè„ˆå‹•
    var fastPulse = 1 + Math.sin(this.age * 3) * 0.15; // æŒ¯å¹…ã‚’å°ã•ãï¼ˆå…ƒï¼š0.3ï¼‰
    this.innerRing.scale.setScalar(fastPulse);
  }
  
  // æ³¨æ„ï¼šå…‰ã®æŸ±ï¼ˆlightPillarï¼‰ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã¯å‰Šé™¤
  
  // ãƒãƒ¼ã‚«ãƒ¼çƒã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šæ§ãˆã‚ã«ï¼‰
  if (this.marker) {
    this.marker.material.opacity = opacity * 0.4; // åŸºæœ¬é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå…ƒï¼š0.7ï¼‰
    
    // ãƒã‚¦ãƒ³ã‚¹åŠ¹æœã‚’ç©ã‚„ã‹ã«
    var bounce = Math.sin(this.age * 3) * 1; // æŒ¯å¹…ã‚’å°ã•ãï¼ˆå…ƒï¼š2ï¼‰
    this.marker.position.y = this.centerPosition.y + 5 + bounce; // åŸºæº–é«˜åº¦ã‚‚ä½ãï¼ˆå…ƒï¼š10ï¼‰
    
    // è‰²ã®å¤‰åŒ–ã‚‚ç©ã‚„ã‹ã«ï¼ˆã‚°ãƒ¬ãƒ¼ç³»ã‚’ç¶­æŒï¼‰
    var grayIntensity = 0.6 + Math.sin(this.age * 2) * 0.1; // ã‚°ãƒ¬ãƒ¼ã®æ¿ƒæ·¡å¤‰åŒ–
    this.marker.material.color.setRGB(grayIntensity, grayIntensity, grayIntensity);
  }
  
  // æ¥ç¶šç·šã®é€æ˜åº¦æ›´æ–°ï¼ˆæ›´ã«è–„ãï¼‰
  this.connections.forEach(function(connection) {
    connection.material.opacity = opacity * 0.3; // åŸºæœ¬é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆå…ƒï¼š0.8ï¼‰
  });
  
  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†ã®åˆ¤å®š
  return this.age < this.maxAge;
};

// ãƒªã‚½ãƒ¼ã‚¹ã®å®Œå…¨ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆå¤‰æ›´ãªã—ï¼‰
ClusterEffect.prototype.dispose = function() {
  console.log('ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‰Šé™¤:', this.visualElements.length + this.connections.length, 'å€‹ã®è¦ç´ ');
  
  // å…¨ã¦ã®è¦–è¦šè¦ç´ ã‚’å‰Šé™¤
  this.visualElements.forEach(function(element) {
    if (element && element.parent) {
      scene.remove(element);
      if (element.geometry) element.geometry.dispose();
      if (element.material) element.material.dispose();
    }
  });
  
  // æ¥ç¶šç·šã‚’å‰Šé™¤
  this.connections.forEach(function(connection) {
    if (connection && connection.parent) {
      scene.remove(connection);
      if (connection.geometry) connection.geometry.dispose();
      if (connection.material) connection.material.dispose();
    }
  });
  
  this.visualElements = [];
  this.connections = [];
};

function Particle(id, position, params, isRecycled) {
  // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®åˆæœŸåŒ–
  this.id = id;
  this.position = position.clone();
  this.velocity = new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
  this.state = 'active';
  this.effectTimer = 0;
  this.params = params;
  this.birthTime = params.currentTime || 0;
  
  // è¦–è¦šåŠ¹æœç”¨ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
  this.positionHistory = [position.clone()]; // è»Œè·¡è¨˜éŒ²ç”¨
  this.maxTrailLength = params.trailLength || 10;
  this.pulseTimer = Math.random() * Math.PI * 2; // ãƒ‘ãƒ«ã‚¹åŠ¹æœç”¨ã®ã‚¿ã‚¤ãƒãƒ¼
  
  // 3Dãƒ¡ãƒƒã‚·ãƒ¥ã®ä½œæˆ
  var geometry = new THREE.SphereGeometry(0.35, 16, 16);
  var material = new THREE.MeshPhongMaterial({
      color: this.getColor(),
      transparent: true,
      opacity: isRecycled ? 0.7 : 0.85,
      emissive: isRecycled ? this.getColor() : 0x000000,
      emissiveIntensity: 0.3
  });
  this.mesh = new THREE.Mesh(geometry, material);
  this.mesh.position.copy(this.position);
  scene.add(this.mesh);
  
  // ãƒˆãƒ¬ã‚¤ãƒ«ãƒ©ã‚¤ãƒ³ç”¨ã®åˆæœŸåŒ–
  this.trailLine = null;
  this.createTrail();
  
  return this;
}

// ãƒˆãƒ¬ã‚¤ãƒ«ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰ - ç²’å­ã®è»Œè·¡ã‚’å¯è¦–åŒ–ï¼ˆå¤§å¹…æ”¹å–„ç‰ˆï¼‰
Particle.prototype.createTrail = function() {
  if (this.params.showTrails && !this.trailLine) {
    var trailGeometry = new THREE.BufferGeometry();
    // è»Œè·¡ã®è¦–èªæ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ã€è‰²ã¨é€æ˜åº¦ã‚’å‹•çš„ã«èª¿æ•´
    var trailMaterial = new THREE.LineBasicMaterial({
      color: this.getColor(),
      transparent: true,
      opacity: this.params.trailOpacity || 0.8,
      linewidth: 2 // è»Œè·¡ã‚’å¤ªãã—ã¦è¦‹ã‚„ã™ã
    });
    this.trailLine = new THREE.Line(trailGeometry, trailMaterial);
    scene.add(this.trailLine);
  }
};

// ãƒˆãƒ¬ã‚¤ãƒ«æ›´æ–°ãƒ¡ã‚½ãƒƒãƒ‰ - ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã§æ™‚é–“ã®æµã‚Œã‚’è¡¨ç¾
Particle.prototype.updateTrail = function() {
  if (!this.params.showTrails || !this.trailLine) return;
  
  // å±¥æ­´ã®é•·ã•ã‚’åˆ¶é™
  if (this.positionHistory.length > this.maxTrailLength) {
    this.positionHistory.shift();
  }
  
  // è»Œè·¡ç·šã®æ›´æ–°ï¼ˆæ”¹å–„ã•ã‚ŒãŸã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœä»˜ãï¼‰
  if (this.positionHistory.length > 1) {
    var positions = [];
    var colors = [];
    var baseColor = this.getColor();
    
    // å„è»Œè·¡ç‚¹ã«å¯¾ã—ã¦ã€æ™‚é–“ã«åŸºã¥ãã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’é©ç”¨
    for (var i = 0; i < this.positionHistory.length; i++) {
      var pos = this.positionHistory[i];
      positions.push(pos.x, pos.y, pos.z);
      
      // æ–°ã—ã„è»Œè·¡ç‚¹ã»ã©é®®æ˜ã«ã€å¤ã„ç‚¹ã»ã©è–„ãè¡¨ç¤º
      // ã“ã‚Œã«ã‚ˆã‚Šã€Œæ™‚é–“ã®æµã‚Œã€ãŒè¦–è¦šçš„ã«ç†è§£ã§ãã‚‹
      var timeRatio = i / (this.positionHistory.length - 1);
      var intensity = 0.3 + 0.7 * timeRatio; // 30%ã‹ã‚‰100%ã¾ã§æ®µéšçš„ã«æ¿ƒã
      colors.push(
        baseColor.r * intensity, 
        baseColor.g * intensity, 
        baseColor.b * intensity
      );
    }
    
    // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®å†æ§‹ç¯‰ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è€ƒæ…®ã—ãŸåŠ¹ç‡çš„ãªæ›´æ–°ï¼‰
    this.trailLine.geometry.dispose();
    this.trailLine.geometry = new THREE.BufferGeometry();
    this.trailLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    this.trailLine.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    // è»Œè·¡ã®è‰²ã‚‚ç²’å­ã®ç¾åœ¨ã®è‰²ã«é€£å‹•ã•ã›ã‚‹
    this.trailLine.material.color = baseColor;
    this.trailLine.material.opacity = this.params.trailOpacity || 0.8;
  }
};

// ãƒ¡ã‚¤ãƒ³ã®æ›´æ–°ãƒ¡ã‚½ãƒƒãƒ‰ - ç‰©ç†æ¼”ç®—ã¨è¦–è¦šåŠ¹æœã®çµ±åˆ
Particle.prototype.update = function(deltaTime, simState, allParticles) {
  // æˆåŠŸ/å¤±æ•—çŠ¶æ…‹ã®å‡¦ç†
  if (this.state === 'succeeding' || this.state === 'disappearing') {
    this.effectTimer += deltaTime;
    var isSucceeding = this.state === 'succeeding';
    var duration = isSucceeding ? 0.5 : 0.8;
    
    if (this.effectTimer >= duration) {
      this.state = 'inactive';
      if (!isSucceeding && Math.random() < this.params.resourceRecyclingRate) {
        recycledParticles.push({ recycleTime: simState.elapsedTime + this.params.recyclingDelay });
      }
    } else {
      // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      var progress = this.effectTimer / duration;
      var scaleMultiplier = isSucceeding ? 3 : 4;
      this.mesh.scale.setScalar(1 + progress * scaleMultiplier);
      this.mesh.material.opacity = (isSucceeding ? 1 : 0.6) * (1 - progress);
      
      if (isSucceeding) {
        this.mesh.material.emissiveIntensity = 0.8 * (1 - progress * 0.5);
      }
      
      if (!isSucceeding) this.position.y += deltaTime * 2;
      this.mesh.position.copy(this.position);
      this.updateTrail();
    }
    return;
  }
  
  if (this.state !== 'active') return;

  // ä½ç½®å±¥æ­´ã¸ã®è¿½åŠ ï¼ˆãƒˆãƒ¬ã‚¤ãƒ«ç”¨ï¼‰
  this.positionHistory.push(this.position.clone());

  // ç‰©ç†æ¼”ç®—ã®å®Ÿè¡Œ
  var hRatio = this.position.y / coneHeight;
  
  // TRTç†è«–ã«åŸºã¥ãå‚ç›´åŠ›ã®è¨ˆç®—
  this.velocity.y += this.params.trtForce * (1-hRatio) * (hRatio < this.params.tippingPoint ? 1 : this.params.trtAcceleration) * deltaTime;
  
  // å¸‚å ´å¼•åŠ›ã®é©ç”¨
  if(hRatio > 0.7 && this.params.marketPull > 0) {
    var marketDirection = new THREE.Vector3(0, this.params.successThreshold - this.position.y, 0).normalize();
    this.velocity.add(marketDirection.multiplyScalar(this.params.marketPull * deltaTime));
  }
  
  // PRAç†è«–ã«åŸºã¥ãæ°´å¹³æ‹¡æ•£åŠ›
  this.velocity.x += (Math.random()-0.5) * this.params.praForce * this.params.praDiversity * deltaTime;
  this.velocity.z += (Math.random()-0.5) * this.params.praForce * this.params.praDiversity * deltaTime;
  
  // å¤šé‡é‡åŠ›æºã®åŠ¹æœ
  if (this.params.multiGravityEnabled) {
    // ä¸­å¤®åæŸåŠ›
    var centralDirection = new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize();
    this.velocity.add(centralDirection.multiplyScalar(this.params.centralConvergence * hRatio * deltaTime));
    
    // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å†…åæŸåŠ›
    var nearby = allParticles.filter(function(p) {
      return p.id !== this.id && p.state === 'active' && this.position.distanceTo(p.position) < this.params.attractionRange;
    }.bind(this));
    
    if (nearby.length >= this.params.clusterThreshold - 1) {
      var clusterCenter = new THREE.Vector3();
      for (var i = 0; i < nearby.length; i++) {
        clusterCenter.add(nearby[i].position);
      }
      clusterCenter.add(this.position);
      clusterCenter.divideScalar(nearby.length + 1);
      
      var clusterDirection = clusterCenter.clone().sub(this.position).normalize();
      this.velocity.add(clusterDirection.multiplyScalar(this.params.clusterConvergence * deltaTime));
    }
  }
  
  // é ‚ç‚¹å®¹é‡åˆ¶é™ã®åŠ¹æœ
  if (this.params.envBiasEnabled && this.position.y > (coneHeight - this.params.capacityRadius * 2)) {
    var nearbyCount = allParticles.filter(function(p) {
      return p.id !== this.id && p.state === 'active' && this.position.distanceTo(p.position) < this.params.capacityRadius;
    }.bind(this)).length;
    
    if (nearbyCount >= this.params.vertexCapacity) {
      this.velocity.y *= this.params.congestionEffect;
    }
  }
  
  // ä½ç½®ã®æ›´æ–°
  this.position.add(this.velocity.clone().multiplyScalar(deltaTime * this.params.timeScale * 10));
  
  // è¦–è¦šåŠ¹æœã®æ›´æ–°
  this.updateVisualEffects(hRatio, deltaTime);
  
  // ãƒ­ã‚°è¨˜éŒ²ï¼ˆã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
  if (simState.log.length < 10000 && Math.random() < 0.1) {
    simState.log.push({
      time: simState.elapsedTime,
      id: this.id,
      x: this.position.x.toFixed(2),
      y: this.position.y.toFixed(2),
      z: this.position.z.toFixed(2)
    });
  }
  
  // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
  var maxRadius = coneRadius * (1 - this.position.y/coneHeight);
  if (Math.hypot(this.position.x, this.position.z) > maxRadius || this.position.y < 0) {
    return this.changeState('disappearing', simState);
  }
  if (this.position.y >= this.params.successThreshold) {
    return this.changeState('succeeding', simState);
  }

  // ãƒ¡ãƒƒã‚·ãƒ¥ä½ç½®ã¨ãƒˆãƒ¬ã‚¤ãƒ«ã®æ›´æ–°
  this.mesh.position.copy(this.position);
  this.updateTrail();
};

// è¦–è¦šåŠ¹æœæ›´æ–°ãƒ¡ã‚½ãƒƒãƒ‰ - é«˜åº¦ã«å¿œã˜ãŸã‚°ãƒ­ãƒ¼ã€ãƒ‘ãƒ«ã‚¹ã€ã‚µã‚¤ã‚ºå¤‰æ›´
Particle.prototype.updateVisualEffects = function(hRatio, deltaTime) {
  // é«˜åº¦ã«å¿œã˜ãŸç™ºå…‰å¼·åº¦
  var glowIntensity = this.params.glowIntensity || 0.5;
  var heightBasedGlow = hRatio * glowIntensity;
  this.mesh.material.emissiveIntensity = heightBasedGlow;
  
  // ãƒ‘ãƒ«ã‚¹åŠ¹æœï¼ˆé«˜åº¦60%ä»¥ä¸Šã§ç™ºå‹•ï¼‰
  if (this.params.pulseEffect && hRatio > 0.6) {
    this.pulseTimer += deltaTime * 8;
    var pulseScale = 1 + Math.sin(this.pulseTimer) * 0.2 * hRatio;
    this.mesh.scale.setScalar(pulseScale);
    
    // ç™ºå…‰å¼·åº¦ã‚‚ãƒ‘ãƒ«ã‚¹
    this.mesh.material.emissiveIntensity = heightBasedGlow + Math.sin(this.pulseTimer) * 0.3 * hRatio;
  } else {
    this.mesh.scale.setScalar(1);
  }
  
  // è‰²ã¨é€æ˜åº¦ã®å‹•çš„æ›´æ–°
  this.mesh.material.color = this.getColor();
  this.mesh.material.opacity = 0.6 + 0.4 * hRatio;
  
  // é‡è¦åº¦ã«å¿œã˜ãŸã‚µã‚¤ã‚ºèª¿æ•´
  var sizeMultiplier = 1 + hRatio * 0.3;
  if (!this.params.pulseEffect || hRatio <= 0.6) {
    this.mesh.scale.setScalar(sizeMultiplier);
  }
};

// çŠ¶æ…‹å¤‰æ›´ãƒ¡ã‚½ãƒƒãƒ‰
Particle.prototype.changeState = function(newState, simState) {
  if (this.state === 'active') { 
    this.state = newState; 
    this.effectTimer = 0; 
    if (newState === 'succeeding' && simState) {
      simState.successCount++;
    }
  }
};

// è‰²å–å¾—ãƒ¡ã‚½ãƒƒãƒ‰ - é«˜åº¦ã«åŸºã¥ãã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
Particle.prototype.getColor = function() {
  var hRatio = this.position.y / coneHeight;
  var color = new THREE.Color();
  
  // æ®µéšçš„ãªè‰²ã®è£œé–“
  if (hRatio < 0.33) {
    color.lerpColors(colorStops.green, colorStops.yellow, hRatio / 0.33);
  } else if (hRatio < 0.66) {
    color.lerpColors(colorStops.yellow, colorStops.pink, (hRatio - 0.33) / 0.33);
  } else {
    color.lerpColors(colorStops.pink, colorStops.red, (hRatio - 0.66) / 0.34);
  }
  
  // å½©åº¦ã¨æ˜åº¦ã®èª¿æ•´
  var hsl = {};
  color.getHSL(hsl);
  hsl.s = 0.6 + 0.4 * hRatio;
  hsl.l = 0.7 - 0.2 * hRatio;
  color.setHSL(hsl.h, hsl.s, hsl.l);
  
  return color;
};

// ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ãƒ¡ã‚½ãƒƒãƒ‰
Particle.prototype.removeMesh = function() { 
  if (this.mesh && this.mesh.parent) { 
    scene.remove(this.mesh); 
    if (this.mesh.geometry) this.mesh.geometry.dispose(); 
    if (this.mesh.material) this.mesh.material.dispose(); 
    this.mesh = null; 
  }
  
  if (this.trailLine && this.trailLine.parent) {
    scene.remove(this.trailLine);
    if (this.trailLine.geometry) this.trailLine.geometry.dispose();
    if (this.trailLine.material) this.trailLine.material.dispose();
    this.trailLine = null;
  }
};

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºæ©Ÿèƒ½
function showMessage(text, type) {
  var messageArea = document.getElementById('message-area');
  var messageDiv = document.createElement('div');
  messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
  messageDiv.textContent = text;
  messageArea.appendChild(messageDiv);
  setTimeout(function() { 
    if (messageDiv.parentNode) messageDiv.parentNode.removeChild(messageDiv); 
  }, 5000);
}

// åˆæœŸåŒ–é–¢æ•°
function init() {
  try {
    // Three.jsã®åŸºæœ¬è¨­å®š
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(40, 40, 40);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¨­å®š
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, coneHeight/2, 0);
    controls.enableDamping = true;

    // ç…§æ˜ã®è¨­å®š
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    var dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    // ã‚°ãƒªãƒƒãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã®è¿½åŠ 
    var gridHelper = new THREE.GridHelper(coneRadius * 2, 20, 0x888888, 0xcccccc);
    gridHelper.material.opacity = 0.15;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);

    // å††éŒæ§‹é€ ã®ä½œæˆ
    createConeGeometry();
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
    window.addEventListener('resize', onWindowResize);
    setupUIListeners();
    updateParameters();
    resetSimulation();
    animate();
    
    showMessage('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãŒæ­£å¸¸ã«åˆæœŸåŒ–ã•ã‚Œã¾ã—ãŸï¼ˆæœ€é©åŒ–ç‰ˆï¼‰', 'success');
  } catch (error) {
    showMessage('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
    console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
  }
}

// å††éŒã‚¸ã‚ªãƒ¡ãƒˆãƒªã®ä½œæˆ
function createConeGeometry() {
  coneGroup = new THREE.Group();
  scene.add(coneGroup);
  
  var coneSegments = 4;
  var segmentHeight = coneHeight / coneSegments;
  var coneWallColor = new THREE.Color(0xA0C0E0);
  var wireframeDensity = [16, 12, 12, 8];
  
  // é€æ˜ãªå††éŒå£
  var fullConeGeom = new THREE.CylinderGeometry(0, coneRadius, coneHeight, 32, 4, true);
  var fullConeMat = new THREE.MeshPhongMaterial({
      color: coneWallColor,
      transparent: true,
      opacity: 0.1,
      side: THREE.DoubleSide
  });
  var fullCone = new THREE.Mesh(fullConeGeom, fullConeMat);
  fullCone.position.y = coneHeight / 2;
  coneGroup.add(fullCone);
  
  // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ãƒªãƒ³ã‚°ã®è¿½åŠ 
  for (var i = 0; i < coneSegments; i++) {
      var bottomY = i * segmentHeight;
      var topY = (i + 1) * segmentHeight;
      var bottomRadius = coneRadius * (1 - bottomY / coneHeight);
      var topRadius = coneRadius * (1 - topY / coneHeight);
      
      // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ©ã‚¤ãƒ³
      var points = [];
      var numLines = wireframeDensity[i];
      for (var j = 0; j < numLines; j++) {
          var angle = (j / numLines) * Math.PI * 2;
          points.push(new THREE.Vector3(Math.cos(angle) * bottomRadius, -segmentHeight/2, Math.sin(angle) * bottomRadius));
          points.push(new THREE.Vector3(Math.cos(angle) * topRadius, segmentHeight/2, Math.sin(angle) * topRadius));
      }
      var lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.2 - i * 0.01 });
      var line = new THREE.LineSegments(lineGeometry, lineMaterial);
      line.position.y = bottomY + segmentHeight / 2;
      coneGroup.add(line);

      // é«˜ã•ãƒ¬ãƒ™ãƒ«ã®ãƒªãƒ³ã‚°
      var ringGeom = new THREE.RingGeometry(bottomRadius - 0.1, bottomRadius, 64);
      var ringMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
      var ring = new THREE.Mesh(ringGeom, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = bottomY;
      coneGroup.add(ring);
  }
}

// åˆæœŸé…ç½®æˆ¦ç•¥ã«åŸºã¥ãä½ç½®è¨ˆç®—
function getInitialPosition(strategy, index, total) {
  var angle = (index / total) * Math.PI * 2;
  var baseRadius = coneRadius * 0.9;
  
  switch (strategy) {
    case 'focused':
      return new THREE.Vector3(
        Math.cos(angle) * baseRadius * 0.3,
        1,
        Math.sin(angle) * baseRadius * 0.3
      );
    case 'diversified':
      return new THREE.Vector3(
        Math.cos(angle) * (0.3 + Math.random() * 0.6) * baseRadius,
        1,
        Math.sin(angle) * (0.3 + Math.random() * 0.6) * baseRadius
      );
    case 'clustered':
      var clusterAngle = Math.floor(index / (total / 4)) * Math.PI / 2;
      var clusterRadius = baseRadius * 0.5;
      return new THREE.Vector3(
        Math.cos(clusterAngle) * clusterRadius + (Math.random() - 0.5) * 3,
        1,
        Math.sin(clusterAngle) * clusterRadius + (Math.random() - 0.5) * 3
      );
    case 'edge':
      return new THREE.Vector3(
        Math.cos(angle) * baseRadius * (0.8 + Math.random() * 0.2),
        1,
        Math.sin(angle) * baseRadius * (0.8 + Math.random() * 0.2)
      );
    default: // random
      return new THREE.Vector3(
        Math.cos(angle) * Math.random() * baseRadius,
        1,
        Math.sin(angle) * Math.random() * baseRadius
      );
  }
}

// ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰æ›´æ–°
function updateCameraMode() {
  if (!camera || !controls) return;
  
  var mode = parameters.cameraMode || 'free';
  
  if (mode !== currentCameraMode) {
    currentCameraMode = mode;
    
    if (!originalCameraPosition) {
      originalCameraPosition = camera.position.clone();
    }
    
    switch (mode) {
      case 'side':
        camera.position.set(coneRadius * 2.5, coneHeight / 2, 0);
        controls.target.set(0, coneHeight / 2, 0);
        break;
        
      case 'tracking':
        var highestParticle = particles
          .filter(function(p) { return p.state === 'active'; })
          .sort(function(a, b) { return b.position.y - a.position.y; })[0];
        
        if (highestParticle) {
          cameraTarget = highestParticle;
        }
        break;
        
      default:
        camera.position.copy(originalCameraPosition);
        controls.target.set(0, coneHeight/2, 0);
        cameraTarget = null;
        break;
    }
  }
  
  if (mode === 'tracking' && cameraTarget && cameraTarget.state === 'active') {
    var targetPos = cameraTarget.position.clone();
    targetPos.y += 10;
    camera.position.lerp(targetPos.add(new THREE.Vector3(15, 5, 15)), 0.05);
    controls.target.copy(cameraTarget.position);
  }
}

// åˆæœŸç²’å­ã®ä½œæˆ
function createInitialParticles(params, state, arr) { 
  // æ—¢å­˜ç²’å­ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  arr.forEach(function(p) { p.removeMesh(); }); 
  arr.length = 0; 
  nextParticleId = 0; 
  state.totalSpawned = 0; 
  
  // æ–°ã—ã„ç²’å­ã®ä½œæˆ
  for(var i = 0; i < params.initialParticles; i++) {
    var position = getInitialPosition(params.initialPlacementStrategy, i, params.initialParticles);
    arr.push(new Particle(nextParticleId++, position, params)); 
  } 
  state.totalSpawned += params.initialParticles; 
}

// å†åˆ©ç”¨ç²’å­ã®å‡¦ç†
function processRecycledParticles(params, state, arr) { 
  var currentTime = state.elapsedTime; 
  var toRecycleNow = recycledParticles.filter(function(r) { return r.recycleTime <= currentTime; }); 
  toRecycleNow.forEach(function() { 
    var angle = Math.random()*Math.PI*2;
    var radius = Math.random()*coneRadius*0.8; 
    arr.push(new Particle(nextParticleId++, new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius), params, true)); 
    state.recycledCount++; 
  }); 
  recycledParticles = recycledParticles.filter(function(r) { return r.recycleTime > currentTime; }); 
}

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ›´æ–°
function updateParameters() { 
  var elements = document.querySelectorAll('#control-panel input, #control-panel select');
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    parameters[el.id] = (el.type==='checkbox') ? el.checked : (el.type==='range'||el.type==='number') ? parseFloat(el.value) : el.value; 
    var valEl = document.getElementById(el.id+'-value'); 
    if(valEl) valEl.textContent = parameters[el.id]; 
  }
  
  parameters.successThreshold = coneHeight - 2; 
  parameters.currentTime = simulationState.elapsedTime;
  
  if (coneGroup) {
    coneGroup.rotation.set(
      THREE.MathUtils.degToRad(parameters.coneTiltX || 0), 
      0, 
      THREE.MathUtils.degToRad(parameters.coneTiltZ || 0)
    );
  }
  
  // æ©Ÿèƒ½ã®ã‚ªãƒ³/ã‚ªãƒ•åˆ¶å¾¡
  var checkboxIds = ['multiGravityEnabled', 'envBiasEnabled'];
  for (var i = 0; i < checkboxIds.length; i++) {
    var id = checkboxIds[i];
    var checkbox = document.querySelector('#' + id);
    if (checkbox) {
      var group = checkbox.closest('.parameter-group');
      if (group) {
        var inputs = group.querySelectorAll('input,select');
        for (var j = 0; j < inputs.length; j++) {
          if (inputs[j].id !== id) {
            inputs[j].disabled = !parameters[id];
          }
        }
      }
    }
  }
}

// çµ±è¨ˆæƒ…å ±ã®æ›´æ–°ï¼ˆå¼·åŠ›ãªãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ä»˜ãï¼‰
function updateStats() { 
  document.getElementById('sim-time').textContent = simulationState.elapsedTime.toFixed(1); 
  document.getElementById('success-count').textContent = simulationState.successCount; 
  document.getElementById('active-particles').textContent = particles.filter(function(p) { return p.state==='active'; }).length; 
  document.getElementById('total-spawned').textContent = simulationState.totalSpawned; 
  document.getElementById('recycled-count').textContent = simulationState.recycledCount; 
  
  // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆã®è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°æƒ…å ±ä»˜ãï¼‰
  var currentClusters = clusterStats.currentClusters;
  var totalClusters = clusterStats.totalClustersFormed;
  var maxClusterSize = clusterStats.maxClusterSize;
  
  document.getElementById('current-clusters').textContent = currentClusters;
  document.getElementById('total-clusters').textContent = totalClusters;
  document.getElementById('max-cluster-size').textContent = maxClusterSize;
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šçµ±è¨ˆæ›´æ–°ã®ç¢ºèªï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å®šæœŸçš„ã«å‡ºåŠ›ï¼‰
  if (Math.floor(simulationState.elapsedTime) !== Math.floor(simulationState.elapsedTime - 0.1) && simulationState.elapsedTime > 1) {
    console.log('=== çµ±è¨ˆçŠ¶æ³ãƒ¬ãƒãƒ¼ãƒˆï¼ˆ1ç§’æ¯ï¼‰ ===');
    console.log('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“:', simulationState.elapsedTime.toFixed(1), 'ç§’');
    console.log('æ´»æ€§ç²’å­æ•°:', particles.filter(function(p) { return p.state==='active'; }).length);
    console.log('ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ•°:', currentClusters);
    console.log('ç´¯è¨ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆ:', totalClusters);
    console.log('æœ€å¤§ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚µã‚¤ã‚º:', maxClusterSize);
    console.log('ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ•°:', clusterEffects.length);
    
    // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã®å¿…è¦æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
    var activeParticles = particles.filter(function(p) { return p.state === 'active'; }).length;
    var canDetectClusters = (
      parameters.clusterEffect && 
      parameters.multiGravityEnabled && 
      activeParticles >= parameters.clusterThreshold &&
      parameters.attractionRange > 0
    );
    
    console.log('ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºå¯èƒ½çŠ¶æ…‹:', canDetectClusters);
    if (!canDetectClusters) {
      console.log('æ¤œå‡ºä¸å¯ã®ç†ç”±:');
      if (!parameters.clusterEffect) console.log('- ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹');
      if (!parameters.multiGravityEnabled) console.log('- å¤šé‡é‡åŠ›æ©Ÿèƒ½ãŒç„¡åŠ¹');
      if (activeParticles < parameters.clusterThreshold) console.log('- ç²’å­æ•°ä¸è¶³ (', activeParticles, '<', parameters.clusterThreshold, ')');
      if (parameters.attractionRange <= 0) console.log('- å¼•åŠ›ç¯„å›²ãŒç„¡åŠ¹ (', parameters.attractionRange, ')');
    }
  }
  
  var rate = simulationState.totalSpawned>0 ? (simulationState.successCount/simulationState.totalSpawned)*100 : 0; 
  document.getElementById('success-rate').textContent = rate.toFixed(1)+'%'; 
  
  // é‡è¦ï¼šã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆãŒæ›´æ–°ã•ã‚Œãªã„å ´åˆã®è­¦å‘Š
  if (simulationState.elapsedTime > 5 && totalClusters === 0 && particles.filter(function(p) { return p.state==='active'; }).length >= 5) {
    // 5ç§’çµŒéã—ã¦ååˆ†ãªç²’å­ãŒã‚ã‚‹ã®ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆ
    if (Math.floor(simulationState.elapsedTime) % 3 === 0) { // 3ç§’æ¯ã«è­¦å‘Š
      console.warn('âš ï¸ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºç•°å¸¸: ååˆ†ãªç²’å­ãŒã‚ã‚‹ã®ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“');
      console.log('å¯¾å‡¦æ–¹æ³•ï¼š');
      console.log('1. ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼å½¢æˆé–¾å€¤ã‚’ä¸‹ã’ã¦ã¿ã¦ãã ã•ã„ï¼ˆç¾åœ¨:', parameters.clusterThreshold, 'ï¼‰');
      console.log('2. å¼•åŠ›ä½œç”¨ç¯„å›²ã‚’åºƒã’ã¦ã¿ã¦ãã ã•ã„ï¼ˆç¾åœ¨:', parameters.attractionRange, 'ï¼‰');
      console.log('3. ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„');
    }
  }
}

// ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã®å¼·åŒ–ï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆã‚‚ãƒªã‚»ãƒƒãƒˆï¼‰
function resetSimulation() {
  simulationState.isRunning = false; 
  simulationState.isPaused = true;
  simulationState.elapsedTime = 0; 
  simulationState.lastSpawnTime = 0;
  simulationState.successCount = 0; 
  simulationState.recycledCount = 0;
  simulationState.log = []; 
  recycledParticles = [];
  
  // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆã®ãƒªã‚»ãƒƒãƒˆ
  clusterStats.currentClusters = 0;
  clusterStats.totalClustersFormed = 0;
  clusterStats.maxClusterSize = 0;
  clusterStats.lastDetectionTime = 0;
  
  // æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  clusterEffects.forEach(function(effect) {
    effect.dispose();
  });
  clusterEffects = [];
  
  createInitialParticles(parameters, simulationState, particles);
  updateStats();
  showMessage('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ', 'info');
  console.log('ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨ãƒªã‚»ãƒƒãƒˆï¼šã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼çµ±è¨ˆã‚‚ã‚¯ãƒªã‚¢');
}

// ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡é–¢æ•°
function startSimulation() { 
  simulationState.isRunning = true; 
  simulationState.isPaused = false; 
  showMessage('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
}

function pauseSimulation() { 
  if (simulationState.isRunning) {
    simulationState.isPaused = true; 
    showMessage('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã—ãŸ', 'info');
  }
}

function resetSimulation() {
  simulationState.isRunning = false; 
  simulationState.isPaused = true;
  simulationState.elapsedTime = 0; 
  simulationState.lastSpawnTime = 0;
  simulationState.successCount = 0; 
  simulationState.recycledCount = 0;
  simulationState.log = []; 
  recycledParticles = [];
  createInitialParticles(parameters, simulationState, particles);
  updateStats();
  showMessage('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ', 'info');
}

// CSVå‡ºåŠ›æ©Ÿèƒ½
function exportCSV() { 
  if(simulationState.log.length === 0){ 
    showMessage('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', 'error'); 
    return; 
  } 
  var csv = 'time,particle_id,x,y,z\n' + simulationState.log.map(function(r) {
    return r.time + ',' + r.id + ',' + r.x + ',' + r.y + ',' + r.z;
  }).join('\n');
  downloadCSV(csv, 'simulation_log.csv'); 
  showMessage('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
}

// ã‚·ãƒŠãƒªã‚ªç®¡ç†æ©Ÿèƒ½
function addScenario() { 
  var paramCopy = JSON.parse(JSON.stringify(parameters));
  var scenarioName = 'ã‚·ãƒŠãƒªã‚ª ' + (scenarios.length + 1) + ': ' + paramCopy.initialPlacementStrategy; 
  scenarios.push({ name: scenarioName, params: paramCopy }); 
  var li = document.createElement('li'); 
  li.textContent = scenarioName;
  li.onclick = function() { showMessage('ã‚·ãƒŠãƒªã‚ªè¨­å®š: ' + scenarioName, 'info'); };
  document.getElementById('scenario-list').appendChild(li); 
  document.getElementById('runComparisonBtn').disabled = false; 
  showMessage('ã‚·ãƒŠãƒªã‚ªã‚’è¿½åŠ ã—ã¾ã—ãŸ', 'success');
}

function runComparison() {
  if (scenarios.length < 2) {
    showMessage('æ¯”è¼ƒã«ã¯å°‘ãªãã¨ã‚‚2ã¤ã®ã‚·ãƒŠãƒªã‚ªãŒå¿…è¦ã§ã™', 'error');
    return;
  }
  
  showMessage('ã‚·ãƒŠãƒªã‚ªæ¯”è¼ƒã‚’å®Ÿè¡Œä¸­...', 'info');
  document.getElementById('runComparisonBtn').disabled = true;
  
  comparisonResults = [];
  var duration = parseFloat(document.getElementById('comparisonDuration').value);
  
  for (var i = 0; i < scenarios.length; i++) {
    var scenario = scenarios[i];
    var result = runHeadlessSim(scenario.params, duration);
    comparisonResults.push({
      scenario: scenario.name,
      successCount: result.successCount,
      totalSpawned: result.totalSpawned,
      successRate: result.successRate,
      finalActiveCount: result.finalActiveCount
    });
  }
  
  var resultText = 'ã‚·ãƒŠãƒªã‚ªæ¯”è¼ƒçµæœ:\n';
  for (var i = 0; i < comparisonResults.length; i++) {
    var result = comparisonResults[i];
    resultText += result.scenario + ': æˆåŠŸç‡ ' + result.successRate.toFixed(1) + '%, æˆåŠŸæ•° ' + result.successCount + '\n';
  }
  
  showMessage(resultText, 'success');
  document.getElementById('exportComparisonBtn').disabled = false;
  document.getElementById('runComparisonBtn').disabled = false;
}

function runHeadlessSim(params, duration) {
  var simParticles = [];
  var simNextId = 0;
  var simState = {
    elapsedTime: 0,
    lastSpawnTime: 0,
    successCount: 0,
    totalSpawned: 0
  };
  
  // åˆæœŸç²’å­ã®ä½œæˆ
  for(var i = 0; i < params.initialParticles; i++) {
    var position = getInitialPosition(params.initialPlacementStrategy, i, params.initialParticles);
    simParticles.push({
      id: simNextId++,
      position: position.clone(),
      velocity: new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05),
      state: 'active'
    });
  }
  simState.totalSpawned = params.initialParticles;
  
  var timeStep = 0.1;
  var steps = Math.floor(duration / timeStep);
  
  for (var step = 0; step < steps; step++) {
    simState.elapsedTime += timeStep;
    
    // æ–°ç²’å­ã®ç”Ÿæˆ
    if (simState.elapsedTime - simState.lastSpawnTime >= params.spawnInterval) {
      for(var i = 0; i < params.batchSize; i++) {
        var angle = Math.random() * Math.PI * 2;
        var radius = Math.random() * coneRadius * 0.9;
        simParticles.push({
          id: simNextId++,
          position: new THREE.Vector3(Math.cos(angle)*radius, 1, Math.sin(angle)*radius),
          velocity: new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05),
          state: 'active'
        });
      }
      simState.totalSpawned += params.batchSize;
      simState.lastSpawnTime = simState.elapsedTime;
    }
    
    // ç²’å­ã®æ›´æ–°
    simParticles = simParticles.filter(function(p) {
      if (p.state !== 'active') return false;
      
      var hRatio = p.position.y / coneHeight;
      p.velocity.y += params.trtForce * (1-hRatio) * (hRatio < params.tippingPoint ? 1 : params.trtAcceleration) * timeStep;
      p.velocity.x += (Math.random()-0.5) * params.praForce * params.praDiversity * timeStep;
      p.velocity.z += (Math.random()-0.5) * params.praForce * params.praDiversity * timeStep;
      
      p.position.add(p.velocity.clone().multiplyScalar(timeStep * params.timeScale * 10));
      
      var maxRadius = coneRadius * (1 - p.position.y/coneHeight);
      if (Math.hypot(p.position.x, p.position.z) > maxRadius || p.position.y < 0) {
        return false;
      }
      if (p.position.y >= params.successThreshold) {
        simState.successCount++;
        return false;
      }
      
      return true;
    });
  }
  
  var successRate = simState.totalSpawned > 0 ? (simState.successCount / simState.totalSpawned) * 100 : 0;
  return {
    successCount: simState.successCount,
    totalSpawned: simState.totalSpawned,
    successRate: successRate,
    finalActiveCount: simParticles.length
  };
}

function exportComparisonCSV() {
  if (comparisonResults.length === 0) {
    showMessage('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹æ¯”è¼ƒçµæœãŒã‚ã‚Šã¾ã›ã‚“', 'error');
    return;
  }
  
  var headers = 'scenario,success_count,total_spawned,success_rate,final_active_count\n';
  var csv = headers + comparisonResults.map(function(r) {
    return '"' + r.scenario + '",' + r.successCount + ',' + r.totalSpawned + ',' + r.successRate.toFixed(2) + ',' + r.finalActiveCount;
  }).join('\n');
  
  downloadCSV(csv, 'scenario_comparison.csv');
  showMessage('æ¯”è¼ƒçµæœã‚’CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 'success');
}

// è¶…ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— - ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã‚’ç¢ºå®Ÿã«å®Ÿè¡Œ
var clock = new THREE.Clock();
var clusterDetectionCounter = 0; // æ¤œå‡ºå®Ÿè¡Œå›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ

function animate() {
  requestAnimationFrame(animate);
  
  if (controls) controls.update();
  updateCameraMode();
  
  if (!simulationState.isPaused && simulationState.isRunning) {
    var deltaTime = Math.min(clock.getDelta(), 0.1);
    simulationState.elapsedTime += deltaTime * parameters.timeScale;
    
    processRecycledParticles(parameters, simulationState, particles);
    
    // æ–°ã—ã„ç²’å­ã®ç”Ÿæˆ
    if (simulationState.elapsedTime - simulationState.lastSpawnTime >= parameters.spawnInterval) {
      for(var i = 0; i < parameters.batchSize; i++){
        var angle = Math.random() * Math.PI * 2;
        var radius = Math.random() * coneRadius * 0.9;
        particles.push(new Particle(nextParticleId++, new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius), parameters));
      }
      simulationState.totalSpawned += parameters.batchSize;
      simulationState.lastSpawnTime = simulationState.elapsedTime;
    }
    
    // ç²’å­ã®ç‰©ç†æ¼”ç®—æ›´æ–°
    particles.forEach(function(p) { p.update(deltaTime, simulationState, particles); });
    
    // ğŸš¨ é‡è¦ï¼šã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã‚’å¤§å¹…ã«ç°¡ç´ åŒ– ğŸš¨
    // è¤‡é›‘ãªæ¡ä»¶ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã€åŸºæœ¬çš„ãªæ¡ä»¶ã®ã¿ã§ãƒ†ã‚¹ãƒˆ
    var activeParticles = particles.filter(function(p) { return p.state === 'active'; });
    
    // 30ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›ï¼ˆç´„0.5ç§’ã«1å›ï¼‰ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã‚’å®Ÿè¡Œ
    clusterDetectionCounter++;
    if (clusterDetectionCounter >= 30 && activeParticles.length >= 2) {
      clusterDetectionCounter = 0; // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒªã‚»ãƒƒãƒˆ
      
      console.log('ğŸ”¥ === ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºå®Ÿè¡Œ ===');
      console.log('ãƒ•ãƒ¬ãƒ¼ãƒ :', clusterDetectionCounter, 'æ´»æ€§ç²’å­æ•°:', activeParticles.length);
      console.log('ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿çŠ¶æ…‹:');
      console.log('- clusterEffect:', parameters.clusterEffect);
      console.log('- multiGravityEnabled:', parameters.multiGravityEnabled);
      
      // å¼·åˆ¶çš„ã«å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ç¶šè¡Œï¼‰
      try {
        if (typeof detectClusters === 'function') {
          console.log('âœ… detectClustersé–¢æ•°ãŒåˆ©ç”¨å¯èƒ½');
          var detectedClusters = detectClusters(particles, parameters);
          console.log('ğŸ¯ æ¤œå‡ºçµæœ:', detectedClusters.length, 'å€‹ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼');
          
          if (detectedClusters.length > 0) {
            console.log('ğŸŒŸ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ç™ºè¦‹ï¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆä¸­...');
            if (typeof manageClusterEffects === 'function') {
              manageClusterEffects(detectedClusters, deltaTime);
            } else {
              console.error('âŒ manageClusterEffectsé–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
          } else {
            console.log('âšª ã“ã®æ¤œå‡ºã‚µã‚¤ã‚¯ãƒ«ã§ã¯ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãªã—');
          }
        } else {
          console.error('âŒ detectClustersé–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        }
      } catch (error) {
        console.error('ğŸ’¥ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼æ¤œå‡ºã§ã‚¨ãƒ©ãƒ¼:', error);
        console.log('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.stack);
      }
      
      // çµ±è¨ˆã®å¼·åˆ¶æ›´æ–°ï¼ˆæ¤œå‡ºã¨ã¯ç‹¬ç«‹ã—ã¦ï¼‰
      console.log('ğŸ“Š ç¾åœ¨ã®çµ±è¨ˆçŠ¶æ…‹:');
      console.log('- clusterStats.currentClusters:', clusterStats.currentClusters);
      console.log('- clusterStats.totalClustersFormed:', clusterStats.totalClustersFormed);
      console.log('- clusterStats.maxClusterSize:', clusterStats.maxClusterSize);
    }
    
    // æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°ï¼ˆå¸¸ã«å®Ÿè¡Œï¼‰
    if (clusterEffects.length > 0) {
      try {
        manageClusterEffects([], deltaTime);
      } catch (error) {
        console.warn('ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
      }
    }
    
    // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç²’å­ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    var activeParticlesCleanup = particles.filter(function(p) { return p.state !== 'inactive'; });
    if (activeParticlesCleanup.length < particles.length) {
        particles.filter(function(p) { return p.state === 'inactive'; }).forEach(function(p) { 
          try {
            p.removeMesh(); 
          } catch (error) {
            console.warn('ç²’å­å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
          }
        });
        particles = activeParticlesCleanup;
    }
    
    updateStats();
  }
  
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
function onWindowResize(){
  if (camera && renderer) {
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  }
}

function setupUIListeners() { 
  var elements = document.querySelectorAll('#control-panel input, #control-panel select');
  for (var i = 0; i < elements.length; i++) {
    elements[i].addEventListener('input', updateParameters);
  }
  
  var toggleBtn = document.getElementById('toggle-control-panel');
  if (toggleBtn) {
    toggleBtn.addEventListener('click', function(e) { 
      var content = e.target.closest('.panel').querySelector('.content-wrapper'); 
      if (content) {
        content.style.display = content.style.display === 'none' ? '' : 'none'; 
        e.target.textContent = content.style.display === 'none' ? '[+]' : '[-]'; 
      }
    }); 
  }
}

function downloadCSV(csv, filename) { 
  try {
    var a = document.createElement('a'); 
    a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv;charset=utf-8;'})); 
    a.download = filename; 
    a.click(); 
    URL.revokeObjectURL(a.href); 
  } catch (error) {
    showMessage('CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
  }
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã®åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>

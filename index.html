<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TRT・PRA シミュレータ v5.3 完全統合版</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
body { margin:0; font-family: Arial,sans-serif; background:#f0f0f0; overflow:hidden; }
#canvas-container { position:relative; width:100vw; height:100vh; }
.panel { position:absolute; background:rgba(255,255,255,0.98); padding:20px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; max-height:90vh; overflow-y:auto; }
#control-panel { bottom:20px; left:20px; width:370px; }
#stats-panel { top:20px; right:20px; width:320px; font-size:13px; color:#1f2937; }
h1,h2 { margin-top:0; color:#1f2937; }
h1 { font-size:20px; display: flex; justify-content: space-between; align-items: center; }
h2 { font-size:16px; border-bottom:1px solid #e5e7eb; padding-bottom:8px; margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;}
.parameter-group { margin-bottom:15px; }
.parameter { margin-bottom:10px; }
.parameter label { display:block; font-size:12px; color:#4b5563; margin-bottom:4px; font-weight:600; cursor: help; }
input[type=range], select { width:100%; }
input:disabled { opacity: 0.5; }
.parameter-value { font-size:11px; color:#6b7280; margin-left:8px; float:right; }
.button-group { display:flex; gap:8px; flex-wrap:wrap; margin-top:15px; }
button.btn { flex-grow:1; padding:8px 12px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer; font-size:13px; transition:background 0.2s; }
button.btn:hover { background:#2563eb; }
button.btn-secondary { background:#6b7280; }
button.btn-secondary:hover { background:#4b5563; }
#toggle-control-panel { font-size: 14px; background: none; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px 8px; font-weight: bold; }
h2 input[type=checkbox] { margin-left: 10px; transform: scale(1.2); cursor: pointer;}
.legend { position:absolute; top:20px; left:20px; background:rgba(255,255,255,0.98); padding:15px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.15); z-index:100; font-size:12px; color:#1f2937; }
.legend-item { display:flex; align-items:center; margin-bottom:5px; }
.legend-color { width:15px; height:15px; margin-right:8px; border-radius:3px; }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="legend-panel" class="legend">
  <h2>資源の発展段階</h2>
  <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div>純粋探索</div>
  <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>移行期</div>
  <div class="legend-item"><div class="legend-color" style="background:#f97316"></div>応用開発</div>
  <div class="legend-item"><div class="legend-color" style="background:#10b981"></div>市場活用</div>
</div>
<div id="stats-panel" class="panel">
  <h2>リアルタイム指標</h2>
  <div>シミュレーション時間: <span id="sim-time">0.0</span> 年</div>
  <div>市場化成功数: <span id="success-count">0</span></div>
  <div>成功率: <span id="success-rate">0.0%</span></div>
  <div>活性資源数: <span id="active-particles">0</span></div>
  <div>累計投入資源: <span id="total-spawned">0</span></div>
</div>
<div id="control-panel" class="panel">
  <h1>TRT・PRA シミュレータ v5.3<button id="toggle-control-panel">[-]</button></h1>
  <div class="content-wrapper">
    <div class="parameter-group">
      <h2>戦略的初期配置</h2>
      <div class="parameter">
        <label for="initialPlacementStrategy">初期配置戦略</label>
        <select id="initialPlacementStrategy" onchange="updateParameters()">
          <option value="random">ランダム</option>
          <option value="focused">集中型</option>
          <option value="diversified">分散型</option>
          <option value="clustered">クラスター型</option>
          <option value="edge">エッジ探索型</option>
        </select>
      </div>
      <div class="parameter">
        <label for="initialParticles">初期資源数 <span class="parameter-value" id="initialParticles-value">20</span></label>
        <input type="range" id="initialParticles" min="1" max="100" value="20" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>シミュレーション制御</h2>
      <div class="parameter">
        <label for="timeScale">時間スケール <span class="parameter-value" id="timeScale-value">0.1</span></label>
        <input type="range" id="timeScale" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="spawnInterval">資源投入間隔 (年) <span class="parameter-value" id="spawnInterval-value">0.5</span></label>
        <input type="range" id="spawnInterval" min="0.1" max="2.0" value="0.5" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="batchSize">投入バッチサイズ <span class="parameter-value" id="batchSize-value">3</span></label>
        <input type="range" id="batchSize" min="1" max="10" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>TRT・PRA パラメータ</h2>
      <div class="parameter">
        <label for="trtForce" title="資源を円錐の上方向（市場化方向）へ押し上げる基本的な力。">垂直推進力 <span class="parameter-value" id="trtForce-value">0.015</span></label>
        <input type="range" id="trtForce" min="0" max="0.05" value="0.015" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="trtAcceleration" title="ティッピングポイントを超えた資源の上昇を加速させる度合い。">上昇加速度 <span class="parameter-value" id="trtAcceleration-value">1.0</span></label>
        <input type="range" id="trtAcceleration" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="tippingPoint" title="上昇加速度が働き始める円錐の高さの閾値。">ティッピングポイント <span class="parameter-value" id="tippingPoint-value">0.7</span></label>
        <input type="range" id="tippingPoint" min="0.5" max="0.9" value="0.7" step="0.05" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="praForce" title="資源が水平方向にランダムに移動する力。探索範囲の拡大に寄与。">水平拡散力 <span class="parameter-value" id="praForce-value">0.02</span></label>
        <input type="range" id="praForce" min="0" max="0.05" value="0.02" step="0.001" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="praDiversity" title="水平方向への拡散の多様性を維持する係数。">多様性維持係数 <span class="parameter-value" id="praDiversity-value">1.0</span></label>
        <input type="range" id="praDiversity" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>多重重力源パラメータ <input type="checkbox" id="multiGravityEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="centralConvergence" title="資源が円錐の中心に向かう力。開発の方向性を中央に集約させる。">中央収束力 <span class="parameter-value" id="centralConvergence-value">0.03</span></label>
        <input type="range" id="centralConvergence" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterConvergence" title="形成されたクラスター（技術群）の中心に資源が集まる力。">クラスター内収束力 <span class="parameter-value" id="clusterConvergence-value">0.02</span></label>
        <input type="range" id="clusterConvergence" min="0" max="0.1" value="0.02" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterInertia" title="クラスターがその動きを維持しようとする力。技術群の安定性を示す。">クラスター慣性 <span class="parameter-value" id="clusterInertia-value">0.015</span></label>
        <input type="range" id="clusterInertia" min="0" max="0.05" value="0.015" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="marketPull" title="資源が円錐の頂点（市場化）に引き寄せられる力。市場の魅力を示す。">市場引力 <span class="parameter-value" id="marketPull-value">0.02</span></label>
        <input type="range" id="marketPull" min="0" max="0.05" value="0.02" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="peerAttraction" title="資源同士が互いに引き合う力。知識の共有や協業を模倣する。">粒子間引力 <span class="parameter-value" id="peerAttraction-value">0.01</span></label>
        <input type="range" id="peerAttraction" min="0" max="0.05" value="0.01" step="0.005" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="attractionRange" title="粒子間引力が働く最大の距離。">引力作用範囲 <span class="parameter-value" id="attractionRange-value">5</span></label>
        <input type="range" id="attractionRange" min="2" max="10" value="5" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="clusterThreshold" title="クラスターと見なされるために必要な近接資源の最小数。">クラスター形成閾値 <span class="parameter-value" id="clusterThreshold-value">3</span></label>
        <input type="range" id="clusterThreshold" min="2" max="8" value="3" step="1" oninput="updateParameters()">
      </div>
    </div>
    <div class="parameter-group">
      <h2>環境バイアス・頂点容量制限 <input type="checkbox" id="envBiasEnabled" checked onchange="updateParameters()"></h2>
      <div class="parameter">
        <label for="coneTiltX" title="円錐全体をX軸周りに傾ける。特定分野への技術開発の偏りをシミュレート。">円錐傾斜X軸 <span class="parameter-value" id="coneTiltX-value">0</span></label>
        <input type="range" id="coneTiltX" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="coneTiltZ" title="円錐全体をZ軸周りに傾ける。特定分野への技術開発の偏りをシミュレート。">円錐傾斜Z軸 <span class="parameter-value" id="coneTiltZ-value">0</span></label>
        <input type="range" id="coneTiltZ" min="-30" max="30" value="0" step="5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="vertexCapacity" title="円錐の頂点付近（市場）が一度に受け入れられる資源の最大数。">頂点最大容量 <span class="parameter-value" id="vertexCapacity-value">5</span></label>
        <input type="range" id="vertexCapacity" min="1" max="15" value="5" step="1" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="capacityRadius" title="頂点容量制限が適用される、頂点からの半径。">容量制限半径 <span class="parameter-value" id="capacityRadius-value">2</span></label>
        <input type="range" id="capacityRadius" min="1" max="5" value="2" step="0.5" oninput="updateParameters()">
      </div>
      <div class="parameter">
        <label for="congestionEffect" title="頂点付近の混雑が資源の上昇を妨げる度合い（1に近いほど妨げない）。">混雑効果係数 <span class="parameter-value" id="congestionEffect-value">0.8</span></label>
        <input type="range" id="congestionEffect" min="0.3" max="1.0" value="0.8" step="0.05" oninput="updateParameters()">
      </div>
    </div>
    <div class="button-group">
      <button class="btn" onclick="startSimulation()">開始</button>
      <button class="btn btn-secondary" onclick="pauseSimulation()">一時停止</button>
      <button class="btn btn-secondary" onclick="resetSimulation()">リセット</button>
      <button class="btn" onclick="exportCSV()">CSV出力</button>
    </div>
  </div>
</div>
<script>
let scene, camera, renderer, coneGroup;
let particles = [], nextParticleId = 0;
let animationId;
let simulationState = {
  isRunning: false,
  isPaused: false,
  elapsedTime: 0,
  lastSpawnTime: 0,
  totalSpawned: 0,
  successCount: 0,
  log: []
};
const coneHeight = 40;
const coneRadius = 20;
const parameters = {
  initialPlacementStrategy: 'random',
  initialParticles: 20,
  timeScale: 0.1,
  spawnInterval: 0.5,
  batchSize: 3,
  trtForce: 0.015,
  trtAcceleration: 1.0,
  tippingPoint: 0.7,
  praForce: 0.02,
  praDiversity: 1.0,
  multiGravityEnabled: true,
  centralConvergence: 0.03,
  clusterConvergence: 0.02,
  clusterInertia: 0.015,
  marketPull: 0.02,
  peerAttraction: 0.01,
  attractionRange: 5,
  clusterThreshold: 3,
  successThreshold: 38,
  envBiasEnabled: true,
  coneTiltX: 0,
  coneTiltZ: 0,
  vertexCapacity: 5,
  capacityRadius: 2,
  congestionEffect: 0.8
};

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(40, 40, 40);
  camera.lookAt(0, 10, 0);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(50, 100, 50);
  scene.add(dirLight);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({color:0xe0e0e0}));
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  coneGroup = new THREE.Group();
  scene.add(coneGroup);
  
  // Create sectioned cone
  const coneSegments = 4;
  const segmentHeight = coneHeight / coneSegments;
  const colors = [0x8b5cf6, 0xef4444, 0xf97316, 0x10b981]; // Pure Exp, Transition, Applied Dev, Market Util
  
  for (let i = 0; i < coneSegments; i++) {
      const bottomY = i * segmentHeight;
      const topY = (i + 1) * segmentHeight;
      const bottomRadius = coneRadius * (1 - bottomY / coneHeight);
      const topRadius = coneRadius * (1 - topY / coneHeight);
      
      const segmentGeom = new THREE.CylinderGeometry(topRadius, bottomRadius, segmentHeight, 32, 1, true);
      const segmentMat = new THREE.MeshPhongMaterial({
          color: colors[i],
          transparent: true,
          opacity: 0.2,
          side: THREE.DoubleSide
      });
      const segment = new THREE.Mesh(segmentGeom, segmentMat);
      segment.position.y = bottomY + segmentHeight / 2;
      coneGroup.add(segment);
  }

  window.addEventListener('resize', onWindowResize);
  setupUIListeners();
  updateParameters();
  resetSimulation();
}

class Particle {
  constructor(id, position) {
    this.id = id;
    this.position = position.clone();
    this.velocity = new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.02+0.01, (Math.random()-0.5)*0.05);
    this.age = 0;
    this.isActive = true;
    this.succeeding = false;
    this.succeedingTime = 0;
    this.spawnTime = simulationState.elapsedTime;
    const geometry = new THREE.SphereGeometry(0.3, 16, 16);
    const material = new THREE.MeshPhongMaterial({color:this.getColor()});
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.copy(this.position);
    scene.add(this.mesh);
  }
  
  update(deltaTime) {
    if (this.succeeding) {
        this.succeedingTime += deltaTime;
        const duration = 0.5; // success effect duration in seconds
        if (this.succeedingTime >= duration) {
            this.succeeding = false;
            scene.remove(this.mesh);
        } else {
            const progress = this.succeedingTime / duration;
            const scale = 1 + progress * 2;
            this.mesh.scale.set(scale, scale, scale);
            this.mesh.material.opacity = 1 - progress;
            this.mesh.material.transparent = true;
            this.mesh.material.needsUpdate = true;
        }
        return;
    }
    
    if (!this.isActive) return;

    const hRatio = this.position.y / coneHeight;

    // TRT/PRA Forces
    this.velocity.y += parameters.trtForce * (1-hRatio) * (hRatio < parameters.tippingPoint ? 1 : parameters.trtAcceleration) * deltaTime;
    this.velocity.x += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;
    this.velocity.z += (Math.random()-0.5) * parameters.praForce * parameters.praDiversity * deltaTime;

    // Multi-Gravity Forces
    if (parameters.multiGravityEnabled) {
        const toCenter = new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize();
        this.velocity.add(toCenter.multiplyScalar(parameters.centralConvergence * hRatio * deltaTime));
        if(hRatio > 0.7){ // Market Pull
          const toVertex = new THREE.Vector3(0, parameters.successThreshold - this.position.y, 0);
          this.velocity.add(toVertex.normalize().multiplyScalar(parameters.marketPull * deltaTime));
        }
        // Peer attraction could be added here
    }

    // Environmental Bias / Vertex Capacity
    if (parameters.envBiasEnabled && this.position.y > (coneHeight - parameters.capacityRadius * 2)) {
        let congestion = 0;
        particles.forEach(p => {
            if (p.id !== this.id && p.isActive && this.position.distanceTo(p.position) < parameters.capacityRadius) {
                congestion++;
            }
        });
        if (congestion >= parameters.vertexCapacity) {
            this.velocity.y *= parameters.congestionEffect;
        }
    }
    
    this.position.add(this.velocity.clone().multiplyScalar(deltaTime * parameters.timeScale * 10));
    
    // Boundary checks
    const maxRadius = coneRadius * (1 - this.position.y/coneHeight);
    if (Math.sqrt(this.position.x**2 + this.position.z**2) > maxRadius) {
        this.isActive = false;
    }
    if (this.position.y >= parameters.successThreshold) {
        this.succeed();
        return;
    }
    if (this.position.y < 0) {
        this.isActive = false;
    }
    
    if (this.isActive) {
        this.mesh.position.copy(this.position);
        this.mesh.material.color.set(this.getColor());
        simulationState.log.push({
            time: simulationState.elapsedTime.toFixed(2),
            id: this.id, x: this.position.x.toFixed(2), y: this.position.y.toFixed(2), z: this.position.z.toFixed(2)
        });
    } else {
        scene.remove(this.mesh);
    }
  }

  getColor() {
    const h = this.position.y/coneHeight;
    if (h<0.25) return 0x8b5cf6;
    if (h<0.5) return 0xef4444;
    if (h<0.75) return 0xf97316;
    return 0x10b981;
  }
  
  succeed() {
    if(!this.isActive) return;
    this.isActive = false;
    this.succeeding = true;
    simulationState.successCount++;
  }
}

function createInitialParticles() {
  particles.forEach(p => scene.remove(p.mesh));
  particles = [];
  nextParticleId = 0;
  const count = parameters.initialParticles;
  // Placement strategies... (same as original)
  switch(parameters.initialPlacementStrategy) {
    case 'focused':
      const focus = new THREE.Vector3((Math.random()-0.5)*10, 1, (Math.random()-0.5)*10);
      for(let i=0;i<count;i++){ const pos = focus.clone().add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).multiplyScalar(3)); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    case 'diversified':
      for(let i=0;i<count;i++){ const angle = (i/count)*Math.PI*2; const radius = coneRadius*0.8; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    case 'clustered':
      const clusters = 3;
      for(let i=0;i<clusters;i++){ const angle = (i/clusters)*Math.PI*2; const radius = coneRadius*0.6; const center = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); for(let j=0;j<Math.floor(count/clusters);j++){ const pos = center.clone().add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).multiplyScalar(4)); particles.push(new Particle(nextParticleId++, pos)); }}
      break;
    case 'edge':
      for(let i=0;i<count;i++){ const angle = Math.random()*Math.PI*2; const radius = coneRadius*0.95; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
    default:
      for(let i=0;i<count;i++){ const angle = Math.random()*Math.PI*2; const radius = Math.random()*coneRadius*0.9; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos)); }
      break;
  }
  simulationState.totalSpawned += count;
}

function startSimulation() {
  if(simulationState.isRunning && !simulationState.isPaused) return;
  if(!simulationState.isRunning) {
    resetSimulation();
  }
  simulationState.isRunning = true;
  simulationState.isPaused = false;
  animate();
}
function pauseSimulation() { if(simulationState.isRunning) simulationState.isPaused = !simulationState.isPaused; }
function resetSimulation() {
  cancelAnimationFrame(animationId);
  simulationState.isRunning = false;
  simulationState.isPaused = false;
  simulationState.elapsedTime = 0;
  simulationState.lastSpawnTime = 0;
  simulationState.totalSpawned = 0;
  simulationState.successCount = 0;
  simulationState.log = [];
  particles.forEach(p=>scene.remove(p.mesh));
  particles = [];
  createInitialParticles();
  updateStats();
}
const clock = new THREE.Clock();
function animate() {
  animationId = requestAnimationFrame(animate);
  if(!simulationState.isRunning || simulationState.isPaused) {
    clock.getDelta(); // keep clock ticking
    return;
  }
  const deltaTime = clock.getDelta();
  simulationState.elapsedTime += deltaTime * parameters.timeScale;
  if(simulationState.elapsedTime - simulationState.lastSpawnTime >= parameters.spawnInterval) {
    for(let i=0;i<parameters.batchSize;i++){
      const angle = Math.random()*Math.PI*2; const radius = Math.random()*coneRadius*0.9; const pos = new THREE.Vector3(Math.cos(angle)*radius,1,Math.sin(angle)*radius); particles.push(new Particle(nextParticleId++, pos));
    }
    simulationState.totalSpawned += parameters.batchSize;
    simulationState.lastSpawnTime = simulationState.elapsedTime;
  }
  particles.forEach(p => p.update(deltaTime));
  particles = particles.filter(p => p.isActive || p.succeeding);
  updateStats();
  renderer.render(scene, camera);
}
function updateParameters() {
  document.querySelectorAll('input, select').forEach(el => {
    if (el.type === 'checkbox') {
        parameters[el.id] = el.checked;
    } else {
        parameters[el.id] = el.type === 'range' ? parseFloat(el.value) : el.value;
    }
    const valEl = document.getElementById(el.id+'-value');
    if(valEl) valEl.textContent = parameters[el.id];
  });
  
  // Update cone tilt
  coneGroup.rotation.set(THREE.MathUtils.degToRad(parameters.coneTiltX), 0, THREE.MathUtils.degToRad(parameters.coneTiltZ));

  // Enable/disable parameter groups
  const multiGravityGroup = document.querySelector('#multiGravityEnabled').closest('.parameter-group');
  multiGravityGroup.querySelectorAll('input[type=range]').forEach(input => input.disabled = !parameters.multiGravityEnabled);
  
  const envBiasGroup = document.querySelector('#envBiasEnabled').closest('.parameter-group');
  envBiasGroup.querySelectorAll('input[type=range]').forEach(input => input.disabled = !parameters.envBiasEnabled);
}

function updateStats() {
  document.getElementById('sim-time').textContent = simulationState.elapsedTime.toFixed(1);
  document.getElementById('success-count').textContent = simulationState.successCount;
  document.getElementById('active-particles').textContent = particles.filter(p=>p.isActive).length;
  document.getElementById('total-spawned').textContent = simulationState.totalSpawned;
  const rate = simulationState.totalSpawned>0?(simulationState.successCount/simulationState.totalSpawned)*100:0;
  document.getElementById('success-rate').textContent = rate.toFixed(1)+'%';
}
function exportCSV() {
  if(simulationState.log.length===0){ alert('エクスポートするデータがありません。'); return; }
  let csv = 'time,particle_id,x,y,z\n';
  simulationState.log.forEach(row=>{ csv += `${row.time},${row.id},${row.x},${row.y},${row.z}\n`; });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'simulation_data.csv';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function setupUIListeners() {
    document.querySelectorAll('input, select').forEach(el => {
        el.addEventListener('input', updateParameters);
    });

    document.getElementById('toggle-control-panel').addEventListener('click', () => {
        const content = document.querySelector('#control-panel .content-wrapper');
        const button = document.getElementById('toggle-control-panel');
        const isHidden = content.style.display === 'none';
        content.style.display = isHidden ? '' : 'none';
        button.textContent = isHidden ? '[-]' : '[+]';
    });
}
init();
</script>
</body>
</html>

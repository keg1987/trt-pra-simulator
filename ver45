<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRT・PRA理論 インタラクティブ・シミュレータ v4.1 - 修正版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            background: #f0f0f0;
            overflow: hidden;
            color: #333;
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #control-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 100;
            transition: all 0.3s ease;
        }
        #control-panel.collapsed {
            height: auto;
            max-height: 50px;
            overflow: hidden;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .collapse-button {
            width: 30px;
            height: 30px;
            background: #e5e7eb;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }
        .collapse-button:hover {
            background: #d1d5db;
        }
        .panel-content {
            transition: all 0.3s ease;
        }
        #control-panel.collapsed .panel-content {
            display: none;
        }
        h1 {
            font-size: 18px;
            margin: 0;
            color: #1f2937;
        }
        h2 {
            font-size: 14px;
            margin: 15px 0 10px 0;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 5px;
        }
        .parameter-group {
            background: #f9fafb;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #e5e7eb;
        }
        .parameter {
            margin-bottom: 12px;
        }
        .parameter label {
            display: block;
            font-size: 12px;
            color: #4b5563;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .parameter input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
        }
        .parameter input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            transition: background 0.2s;
        }
        .parameter input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563eb;
        }
        .parameter-value {
            display: inline-block;
            font-size: 11px;
            color: #6b7280;
            margin-left: 8px;
            min-width: 40px;
            text-align: right;
        }
        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            z-index: 100;
            width: 280px;
        }
        /* Notification System Style */
        #notification-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .notification {
            background-color: #2c3e50;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 14px;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.5s, transform 0.5s;
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #control-panel, .stats-panel, .legend, .cluster-visualization {
                position: relative;
                width: auto;
                left: 10px;
                right: 10px;
                top: auto;
                bottom: auto;
                margin: 10px 0;
                max-height: 40vh;
            }
            .stats-panel {
                order: -2; /* Display stats panel first */
            }
            .legend {
                order: -1;
            }
            #canvas-container {
                display: flex;
                flex-direction: column;
            }
        }
        /* (Other existing styles remain the same) */
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-width: 200px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 11px;
        }
        .legend-color, .legend-shape {
            width: 18px;
            height: 18px;
            margin-right: 8px;
        }
        .stat-item {
            margin: 8px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <!-- (HTML structure for panels, legend, etc. remains largely the same) -->
    </div>
    <div id="notification-container"></div>

    <script>
        // --- Notification System ---
        function showNotification(message, duration = 4000) {
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            container.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Animate out and remove
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => {
                    notification.remove();
                });
            }, duration);
        }

        // --- Three.js setup (remains the same) ---
        const scene = new THREE.Scene();
        // ... (camera, renderer, lighting, ground setup)

        // --- Parameters object (remains the same) ---
        const parameters = { /* ... */ };

        // --- Simulation state (remains the same) ---
        const simulationState = { /* ... */ };

        // --- Main groups (remains the same) ---
        // ...

        // --- ResourceParticle Class (Refactored) ---
        class ResourceParticle {
            constructor(id, spawnTime = 0) {
                // ... (constructor logic remains the same)
            }

            // ... (helper functions like setAttributesByType, createMesh, getColorByHeight remain the same)

            update(deltaTime, particles, params) {
                if (!this.isActive) return;

                this._updateState(deltaTime, params);
                if (!this.isActive) return; // Re-check if state changed to inactive

                this._handleVertexCongestion(particles, params);
                this._applyForces(deltaTime, params);
                this._updatePosition(deltaTime, params);
                this._checkBoundaryConstraints(params);
                this._handleSuccess(particles, params);
                this._updateVisuals();
            }

            _updateState(deltaTime, params) {
                this.age += deltaTime * params.timeScale;
                const industryProfile = getCurrentIndustryProfile();

                if (this.age > this.maxAge && this.position.y < params.successThreshold * 0.8) {
                    this.die('natural');
                    return;
                }

                if (Math.random() < industryProfile.attritionRate * deltaTime) {
                    this.die('attrition');
                    return;
                }
            }

            _handleVertexCongestion(particles, params) {
                this.isQueued = false;
                const nearVertexThreshold = params.successThreshold - params.capacityRadius;
                if (this.position.y < nearVertexThreshold || this.hasSucceeded) return;

                const nearVertexParticles = particles.filter(p =>
                    p.isActive && p.position.y >= nearVertexThreshold && !p.hasSucceeded
                );

                if (nearVertexParticles.length > params.vertexCapacity) {
                    this.isQueued = true;
                    this.velocity.y *= params.congestionEffect;

                    switch (params.queueingBehavior) {
                        case 'pushback':
                            if (this.position.y >= params.successThreshold - 0.5) this.velocity.y -= 0.02;
                            break;
                        case 'random':
                            this.velocity.x += (Math.random() - 0.5) * 0.03;
                            this.velocity.z += (Math.random() - 0.5) * 0.03;
                            break;
                        case 'priority':
                            const avgVelocity = nearVertexParticles.reduce((sum, p) => sum + p.velocity.y, 0) / nearVertexParticles.length;
                            if (this.velocity.y < avgVelocity) this.velocity.y *= 0.9;
                            break;
                    }
                }
            }

            _applyForces(deltaTime, params) {
                const heightRatio = this.position.y / coneHeight;

                // TRT & PRA forces
                const trtStrength = params.trtForce * (1 - heightRatio) * params.trtAcceleration * this.trtAffinity;
                this.velocity.y += (heightRatio < params.tippingPoint) ? (trtStrength * deltaTime) : (trtStrength * deltaTime * 1.5);
                
                const praStrength = params.praForce * (1 - heightRatio) * params.praDiversity * this.praAffinity;
                this.velocity.x += (Math.random() - 0.5) * praStrength * deltaTime;
                this.velocity.z += (Math.random() - 0.5) * praStrength * deltaTime;

                // --- Multi-Gravity Forces ---
                this._applyCentralForce(deltaTime, params, heightRatio);
                this._applyClusterForce(deltaTime, params);
                this._applyPeerAttraction(deltaTime, params);
                this._applyPathMemoryForce(deltaTime, params);
            }

            _applyCentralForce(deltaTime, params, heightRatio) {
                 const toCenter = new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize();
                 this.velocity.x += toCenter.x * params.centralConvergence * heightRatio * deltaTime;
                 this.velocity.z += toCenter.z * params.centralConvergence * heightRatio * deltaTime;
            }
            
            _applyClusterForce(deltaTime, params) {
                const myCluster = simulationState.clusters.find(c => c.members.has(this.id));
                if (!myCluster) return;

                // (Cluster force logic remains the same...)
            }

            _applyPeerAttraction(deltaTime, params) {
                // (Peer attraction logic remains the same...)
            }
            
            _applyPathMemoryForce(deltaTime, params) {
                // (Path memory logic remains the same...)
            }

            _updatePosition(deltaTime, params) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime * params.simulationSpeed));
                this.velocity.multiplyScalar(0.98); // Damping
            }
            
            _checkBoundaryConstraints(params) {
                // Added extensive comments for clarity
                // This section handles keeping particles inside the tilted, asymmetric cone.
                
                // 1. Create a transformation matrix to account for the cone's tilt.
                // This allows us to work in the cone's "local" coordinate system.
                const tiltMatrix = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(
                    -params.coneTiltX * Math.PI / 180, 0, -params.coneTiltZ * Math.PI / 180
                ));
                const localPos = this.position.clone().applyMatrix4(tiltMatrix);

                // 2. In the cone's local space, calculate the maximum allowed radius at the particle's height.
                // We also account for the asymmetric shape (elliptical cross-section).
                let effectiveX = localPos.x / params.asymmetryX;
                let effectiveZ = localPos.z / params.asymmetryZ;
                let currentRadius = Math.sqrt(effectiveX ** 2 + effectiveZ ** 2);
                const maxRadiusAtCurrentHeight = coneRadius * (1 - localPos.y / coneHeight);

                // 3. If the particle is outside the boundary, reflect it back inside.
                if (currentRadius > maxRadiusAtCurrentHeight) {
                    const scale = maxRadiusAtCurrentHeight / currentRadius * 0.95; // 0.95 for safety margin
                    localPos.x = (effectiveX * scale) * params.asymmetryX;
                    localPos.z = (effectiveZ * scale) * params.asymmetryZ;
                    
                    // Transform position back to world space
                    this.position.copy(localPos.applyMatrix4(tiltMatrix.clone().invert()));
                    
                    // Adjust velocity for a "bounce" effect
                    const normal = new THREE.Vector3(effectiveX, 0, effectiveZ).normalize();
                    this.velocity.sub(normal.multiplyScalar(2 * this.velocity.dot(normal))).multiplyScalar(0.5);
                }

                // 4. Safety Check: A final failsafe. If the complex math above fails for any edge case,
                // this forcefully teleports the particle back inside the boundary.
                // This prevents particles from escaping the simulation space.
                const finalLocalPos = this.position.clone().applyMatrix4(tiltMatrix);
                const finalRadius = Math.sqrt(
                    (finalLocalPos.x / params.asymmetryX) ** 2 + (finalLocalPos.z / params.asymmetryZ) ** 2
                );
                const finalMaxRadius = coneRadius * (1 - finalLocalPos.y / coneHeight);
                if (finalRadius > finalMaxRadius * 0.99) {
                     const forcedScale = finalMaxRadius * 0.98 / finalRadius;
                     finalLocalPos.x *= forcedScale;
                     finalLocalPos.z *= forcedScale;
                     this.position.copy(finalLocalPos.applyMatrix4(tiltMatrix.clone().invert()));
                }
            }

            _handleSuccess(particles, params) {
                if (this.position.y < params.successThreshold || this.hasSucceeded) return;
                // (Success logic remains the same...)
                this.succeed();
            }

            _updateVisuals() {
                this.mesh.position.copy(this.position);
                const myCluster = simulationState.clusters.find(c => c.members.has(this.id));
                if (!myCluster) {
                    this.mesh.material.color.setHex(this.getColorByHeight());
                }
                // (Opacity and emissive update logic...)
            }

            // ... (succeed, die, recycle, etc. methods remain the same)
        }

        // --- setIndustryParameters (Modified) ---
        function setIndustryParameters(profileName) {
            const profile = industryProfiles[profileName];
            if (!profile) return;
            
            const changedParams = {};

            function updateParam(key, value) {
                if(parameters[key] !== value) {
                    parameters[key] = value;
                    changedParams[key] = value;
                }
            }
            
            if (profileName === 'biotech') {
                updateParam('attritionRate', 0.05);
                updateParam('vertexCapacity', 15);
                updateParam('resourceRecycleRate', 0.9);
                // ... other biotech params
            } else if (profileName === 'software') {
                updateParam('attritionRate', 0.01);
                updateParam('vertexCapacity', 3);
                updateParam('resourceRecycleRate', 0.5);
                // ... other software params
            } // ... etc. for other profiles

            updateParameterDisplays();
            showNotification(`産業プロファイル「${profileName}」を適用。${Object.keys(changedParams).length}個のパラメータが更新されました。`);
        }

        // --- updateClusters (Optimized) ---
        function updateClusters(particles) {
            const activeParticles = particles.filter(p => p.isActive);
            const newClusterData = findClusters(activeParticles);
            
            // Match new clusters to existing ones to avoid recreation
            const matchedOldClusters = new Set();
            const unMatchedNewData = [];

            newClusterData.forEach(newData => {
                let bestMatch = null;
                let minDistance = Infinity;

                simulationState.clusters.forEach(oldCluster => {
                    if (matchedOldClusters.has(oldCluster.id)) return;
                    const distance = oldCluster.center.distanceTo(newData.center);
                    if (distance < parameters.attractionRange && distance < minDistance) {
                        minDistance = distance;
                        bestMatch = oldCluster;
                    }
                });

                if (bestMatch) {
                    bestMatch.updateMembers(newData.members);
                    matchedOldClusters.add(bestMatch.id);
                } else {
                    unMatchedNewData.push(newData);
                }
            });

            // Remove old, unmatched clusters
            simulationState.clusters = simulationState.clusters.filter(c => {
                if (matchedOldClusters.has(c.id)) {
                    return true;
                } else {
                    c.remove();
                    return false;
                }
            });

            // Add new, unmatched clusters
            unMatchedNewData.forEach(newData => {
                const newCluster = new Cluster(
                    `cluster_${Date.now()}_${Math.random()}`,
                    newData.center,
                    newData.members
                );
                simulationState.clusters.push(newCluster);
            });
            
            updateClusterPanel();
        }


        // --- Animation Loop (Modified) ---
        let lastTime = 0;
        let frameCount = 0;
        const pathMemoryUpdateInterval = 15; // Update every 15 frames

        function animate(time) {
            requestAnimationFrame(animate);
            frameCount++;
            
            const deltaTime = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            if (simulationState.isRunning && !simulationState.isPaused) {
                // ... (simulation time, spawning logic)

                particles.forEach(p => p.update(deltaTime, particles, parameters));
                
                // ... (remove inactive particles logic)
                
                if (visibility.clusters) {
                    updateClusters(particles);
                    simulationState.clusters.forEach(cluster => cluster.update(particles));
                }
                
                // --- Optimized Path Memory Update ---
                if (parameters.pathMemoryEnabled && (frameCount % pathMemoryUpdateInterval === 0)) {
                    pathMemory.decay(1 - parameters.pathMemoryPersistence * deltaTime * pathMemoryUpdateInterval);
                    if (visibility.pathMemory) {
                        pathMemory.updateVisual();
                    }
                }
                
                // ... (rest of the animation loop logic)
            }
            
            renderer.render(scene, camera);
        }
        
        animate(0);

        // ... (Event handlers, utility functions, etc. remain the same)
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRT・PRA 戦略シミュレータ v5.1 - 戦略的初期配置</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; font-family: 'Arial', sans-serif; background: #f0f0f0; overflow: hidden; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        .panel { position: absolute; background: rgba(255, 255, 255, 0.98); padding: 20px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.15); z-index: 100; }
        #control-panel { bottom: 20px; left: 20px; width: 340px; max-height: 90vh; overflow-y: auto; }
        #stats-panel { top: 20px; right: 20px; width: 300px; }
        h1, h2 { color: #1f2937; margin-top: 0; }
        h1 { font-size: 20px; }
        h2 { font-size: 16px; border-bottom: 1px solid #e5e7eb; padding-bottom: 8px; margin-bottom: 12px; }
        .parameter-group { margin-bottom: 15px; }
        .parameter { margin-bottom: 10px; }
        .parameter label { display: block; font-size: 12px; color: #4b5563; margin-bottom: 4px; font-weight: 600; }
        .parameter input[type="range"], .parameter select { width: 100%; }
        .parameter-value { font-size: 12px; color: #6b7280; margin-left: 8px; }
        .button-group { display: flex; gap: 8px; margin-top: 15px; flex-wrap: wrap; }
        .btn { padding: 8px 12px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; transition: background 0.2s; flex-grow: 1; }
        .btn:hover { background: #2563eb; }
        .btn-secondary { background: #6b7280; }
        .btn-secondary:hover { background: #4b5563; }
        .stat-item { display: flex; justify-content: space-between; font-size: 12px; margin: 6px 0; }
        .stat-label { color: #4b5563; }
        .stat-value { font-weight: 700; color: #1f2937; }
        .legend { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.98); padding: 15px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.15); z-index: 100; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; font-size: 12px; }
        .legend-color { width: 15px; height: 15px; margin-right: 8px; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="legend-panel" class="panel legend">
        <h2 style="font-size: 14px;">資源の発展段階</h2>
        <div class="legend-item"><div class="legend-color" style="background: #8b5cf6;"></div><span>純粋探索</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #ef4444;"></div><span>移行期</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #f97316;"></div><span>応用開発</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #10b981;"></div><span>市場活用</span></div>
    </div>
    <div id="stats-panel" class="panel">
        <h2>リアルタイム指標</h2>
        <div class="stat-item"><span class="stat-label">シミュレーション時間:</span><span class="stat-value" id="sim-time">0.0年</span></div>
        <div class="stat-item"><span class="stat-label">市場化成功数:</span><span class="stat-value" id="success-count">0</span></div>
        <div class="stat-item"><span class="stat-label">成功率:</span><span class="stat-value" id="success-rate">0.0%</span></div>
        <div class="stat-item"><span class="stat-label">活性資源数:</span><span class="stat-value" id="active-particles">0</span></div>
        <div class="stat-item"><span class="stat-label">累計投入資源:</span><span class="stat-value" id="total-spawned">0</span></div>
    </div>
    <div id="control-panel" class="panel">
        <h1>TRT・PRA 戦略シミュレータ v5.1</h1>
        <div class="parameter-group">
            <h2>戦略的初期配置</h2>
            <div class="parameter">
                <label for="initialPlacementStrategy">初期配置戦略</label>
                <select id="initialPlacementStrategy" onchange="updateParameters()">
                    <option value="random">ランダム</option>
                    <option value="focused">集中型</option>
                    <option value="diversified">分散型</option>
                    <option value="clustered">クラスター型</option>
                    <option value="edge">エッジ探索型</option>
                </select>
            </div>
            <div class="parameter">
                <label for="initialParticles">初期資源数<span class="parameter-value" id="initialParticles-value">20</span></label>
                <input type="range" id="initialParticles" min="1" max="100" value="20" step="1" oninput="updateParameters()">
            </div>
        </div>
        <div class="parameter-group">
            <h2>シミュレーション制御</h2>
            <div class="parameter">
                <label for="timeScale">時間スケール<span class="parameter-value" id="timeScale-value">0.1</span></label>
                <input type="range" id="timeScale" min="0.01" max="1.0" value="0.1" step="0.01" oninput="updateParameters()">
            </div>
            <div class="parameter">
                <label for="spawnInterval">資源投入間隔 (年)<span class="parameter-value" id="spawnInterval-value">0.5</span></label>
                <input type="range" id="spawnInterval" min="0.1" max="2.0" value="0.5" step="0.1" oninput="updateParameters()">
            </div>
            <div class="parameter">
                <label for="batchSize">投入バッチサイズ<span class="parameter-value" id="batchSize-value">3</span></label>
                <input type="range" id="batchSize" min="1" max="10" value="3" step="1" oninput="updateParameters()">
            </div>
            <div class="button-group">
                <button class="btn" onclick="startSimulation()">開始</button>
                <button class="btn btn-secondary" onclick="pauseSimulation()">一時停止</button>
                <button class="btn btn-secondary" onclick="resetSimulation()">リセット</button>
            </div>
        </div>
        <div class="parameter-group">
            <h2>物理パラメータ</h2>
            <div class="parameter">
                <label for="trtForce">垂直推進力<span class="parameter-value" id="trtForce-value">0.015</span></label>
                <input type="range" id="trtForce" min="0" max="0.05" value="0.015" step="0.001" oninput="updateParameters()">
            </div>
            <div class="parameter">
                <label for="praForce">水平拡散力<span class="parameter-value" id="praForce-value">0.02</span></label>
                <input type="range" id="praForce" min="0" max="0.05" value="0.02" step="0.001" oninput="updateParameters()">
            </div>
            <div class="parameter">
                <label for="centralConvergence">中央収束力<span class="parameter-value" id="centralConvergence-value">0.03</span></label>
                <input type="range" id="centralConvergence" min="0" max="0.1" value="0.03" step="0.005" oninput="updateParameters()">
            </div>
        </div>
        <div class="button-group">
             <button class="btn" onclick="exportData()">データ出力 (CSV)</button>
        </div>
    </div>
    <script>
        // === グローバル変数・設定 ===
        let scene, camera, renderer, particles = [], coneGroup, controls;
        let animationFrameId;
        const parameters = {};
        const simulationState = {
            isRunning: false,
            isPaused: false,
            elapsedTime: 0,
            lastSpawnTime: 0,
            totalSpawned: 0,
            successCount: 0,
            log: []
        };
        const coneHeight = 40;
        const coneRadius = 20;

        // === 初期化処理 ===
        function init() {
            // シーン設定
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 40, 40);
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ライト
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // 地面と円錐
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({ color: 0xe0e0e0 }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            coneGroup = new THREE.Group();
            const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 32, 1, true);
            const coneMat = new THREE.MeshPhongMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
            const cone = new THREE.Mesh(coneGeom, coneMat);
            cone.position.y = coneHeight / 2;
            coneGroup.add(cone);
            scene.add(coneGroup);

            // UIの初期化とイベントリスナー設定
            document.querySelectorAll('input, select').forEach(el => el.dispatchEvent(new Event('input')));
            window.addEventListener('resize', onWindowResize);
        }
        
        // === パーティクルクラス ===
        class Particle {
            constructor(id, position, velocity) {
                this.id = id;
                this.position = position;
                this.velocity = velocity || new THREE.Vector3((Math.random() - 0.5) * 0.1, Math.random() * 0.05, (Math.random() - 0.5) * 0.1);
                this.age = 0;
                this.isActive = true;

                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({ color: this.getColor() });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update(deltaTime) {
                if (!this.isActive) return;

                // 物理演算
                const heightRatio = this.position.y / coneHeight;
                this.velocity.y += parameters.trtForce * (1 - heightRatio) * deltaTime;
                this.velocity.x += (Math.random() - 0.5) * parameters.praForce * deltaTime;
                this.velocity.z += (Math.random() - 0.5) * parameters.praForce * deltaTime;
                
                const toCenter = new THREE.Vector3(-this.position.x, 0, -this.position.z).normalize();
                this.velocity.add(toCenter.multiplyScalar(parameters.centralConvergence * heightRatio * deltaTime));

                this.position.add(this.velocity.clone().multiplyScalar(deltaTime * parameters.timeScale * 10));

                // 境界条件
                const maxRadius = coneRadius * (1 - this.position.y / coneHeight);
                if (Math.sqrt(this.position.x**2 + this.position.z**2) > maxRadius) {
                    this.isActive = false; // 外に出たら非アクティブ
                }

                if (this.position.y >= coneHeight) {
                    this.succeed();
                }

                if (this.position.y < 0) {
                     this.isActive = false;
                }

                if (this.isActive) {
                    this.mesh.position.copy(this.position);
                    this.mesh.material.color.set(this.getColor());
                } else {
                    this.remove();
                }
            }

            getColor() {
                const h = this.position.y / coneHeight;
                if (h < 0.25) return 0x8b5cf6;
                if (h < 0.5) return 0xef4444;
                if (h < 0.75) return 0xf97316;
                return 0x10b981;
            }

            succeed() {
                simulationState.successCount++;
                this.isActive = false;
                this.remove();
            }
            
            remove() {
                scene.remove(this.mesh);
            }
        }

        // === シミュレーション制御 ===
        function startSimulation() {
            if (simulationState.isRunning) resetSimulation();
            simulationState.isRunning = true;
            simulationState.isPaused = false;
            animate();
        }
        function pauseSimulation() {
            simulationState.isPaused = !simulationState.isPaused;
        }
        function resetSimulation() {
            cancelAnimationFrame(animationFrameId);
            simulationState.isRunning = false;
            simulationState.isPaused = false;
            simulationState.elapsedTime = 0;
            simulationState.lastSpawnTime = 0;
            simulationState.totalSpawned = 0;
            simulationState.successCount = 0;
            simulationState.log = [];
            
            particles.forEach(p => p.remove());
            particles = [];
            
            createInitialParticles();
            updateStats();
        }

        // === 初期配置機能 ===
        function createInitialParticles() {
            const count = parameters.initialParticles;
            let particleId = 0;
            
            switch (parameters.initialPlacementStrategy) {
                case 'focused':
                    const focusPoint = new THREE.Vector3((Math.random() - 0.5) * 10, 1, (Math.random() - 0.5) * 10);
                    for (let i = 0; i < count; i++) {
                        const pos = focusPoint.clone().add(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5));
                        particles.push(new Particle(particleId++, pos));
                    }
                    break;
                case 'diversified':
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2;
                        const radius = coneRadius * 0.8;
                        const pos = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                        particles.push(new Particle(particleId++, pos));
                    }
                    break;
                case 'clustered':
                    const numClusters = 3;
                    for (let i = 0; i < numClusters; i++) {
                        const angle = (i / numClusters) * Math.PI * 2;
                        const radius = coneRadius * 0.6;
                        const clusterCenter = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                        for (let j = 0; j < Math.floor(count / numClusters); j++) {
                            const pos = clusterCenter.clone().add(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).multiplyScalar(4));
                            particles.push(new Particle(particleId++, pos));
                        }
                    }
                    break;
                case 'edge':
                     for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = coneRadius * 0.95;
                        const pos = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                        particles.push(new Particle(particleId++, pos));
                    }
                    break;
                case 'random':
                default:
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * coneRadius * 0.9;
                        const pos = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                        particles.push(new Particle(particleId++, pos));
                    }
                    break;
            }
            simulationState.totalSpawned += count;
        }

        function spawnParticles(count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * coneRadius * 0.9;
                const pos = new THREE.Vector3(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
                particles.push(new Particle(simulationState.totalSpawned + i, pos));
            }
            simulationState.totalSpawned += count;
        }

        // === メインループ ===
        const clock = new THREE.Clock();
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (!simulationState.isRunning || simulationState.isPaused) return;

            const deltaTime = clock.getDelta();
            simulationState.elapsedTime += deltaTime * parameters.timeScale;

            // スポーン
            if (simulationState.elapsedTime - simulationState.lastSpawnTime > parameters.spawnInterval) {
                spawnParticles(parameters.batchSize);
                simulationState.lastSpawnTime = simulationState.elapsedTime;
            }
            
            // 更新とログ記録
            particles.forEach(p => {
                p.update(deltaTime);
                if (p.isActive) {
                    simulationState.log.push({
                        time: simulationState.elapsedTime.toFixed(2),
                        id: p.id,
                        x: p.position.x.toFixed(2),
                        y: p.position.y.toFixed(2),
                        z: p.position.z.toFixed(2)
                    });
                }
            });
            particles = particles.filter(p => p.isActive);
            
            updateStats();
            renderer.render(scene, camera);
        }

        // === UI & データ処理 ===
        function updateParameters() {
            document.querySelectorAll('input[type="range"], select').forEach(el => {
                parameters[el.id] = el.type === 'range' ? parseFloat(el.value) : el.value;
                const valueEl = document.getElementById(`${el.id}-value`);
                if (valueEl) valueEl.textContent = parameters[el.id];
            });
        }
        
        function updateStats() {
            document.getElementById('sim-time').textContent = `${simulationState.elapsedTime.toFixed(1)}年`;
            document.getElementById('success-count').textContent = simulationState.successCount;
            document.getElementById('active-particles').textContent = particles.length;
            document.getElementById('total-spawned').textContent = simulationState.totalSpawned;
            const successRate = simulationState.totalSpawned > 0 ? (simulationState.successCount / simulationState.totalSpawned) * 100 : 0;
            document.getElementById('success-rate').textContent = `${successRate.toFixed(1)}%`;
        }

        function exportData() {
            if (simulationState.log.length === 0) {
                alert("エクスポートするデータがありません。");
                return;
            }
            let csvContent = "data:text/csv;charset=utf-8,time,particle_id,x,y,z\n";
            simulationState.log.forEach(row => {
                csvContent += `${row.time},${row.id},${row.x},${row.y},${row.z}\n`;
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "simulation_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // === 実行開始 ===
        init();
        updateParameters();
        resetSimulation();
    </script>
</body>
</html>
